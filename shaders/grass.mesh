#version 460
#extension GL_NV_mesh_shader : enable
#include "global_definition.glsl.h"
#include "tile_common.glsl.h"
#include "noise.glsl.h"

out gl_MeshPerVertexNV {
    vec4  gl_Position;
} gl_MeshVerticesNV[];

layout(push_constant) uniform TileUniformBufferObject {
    TileParams tile_params;
};

layout(std430, set = VIEW_PARAMS_SET, binding = VIEW_CAMERA_BUFFER_INDEX) readonly buffer CameraInfoBuffer {
	GameCameraInfo camera_info;
};

layout(set = TILE_PARAMS_SET, binding = ROCK_LAYER_BUFFER_INDEX) uniform sampler2D rock_layer;
layout(set = TILE_PARAMS_SET, binding = SOIL_WATER_LAYER_BUFFER_INDEX) uniform sampler2D soil_water_layer;

layout(location = 0) out VsPsData {
    vec2 tex_coord;
} out_data[];

layout(local_size_x = 16) in;
layout(triangles, max_vertices=256, max_primitives=256) out;
void main()
{
    uint grass_idx = gl_GlobalInvocationID.x;
    uint local_idx = gl_LocalInvocationID.x;
    vec4 hash_values = clamp(hash43(vec3(tile_params.min, grass_idx)), 0.0f, 1.0f);

    // tile world position.
    vec2 pos_xz_ws = tile_params.min + hash_values.xy * tile_params.range;

    // convert tile world position to uv coordinate.
    vec2 world_map_uv = (pos_xz_ws - tile_params.world_min) * tile_params.inv_world_range;

    float ground_height = texture(rock_layer, world_map_uv).x;
    vec2 soil_water_thickness = texture(soil_water_layer, world_map_uv).xy * SOIL_WATER_LAYER_MAX_THICKNESS;
    ground_height += soil_water_thickness.x;

    vec3 grass_root_pos = vec3(pos_xz_ws.x, ground_height, pos_xz_ws.y);

    float angle = hash_values.w * 2.0f * 3.1415926 + tile_params.time;
    vec2 sincos_xy = vec2(sin(angle), cos(angle));

    vec2 vert_info[] = {
        vec2(0.022, 0.0f),
        vec2(0.025, 0.3f),
        vec2(0.03, 0.4f),
        vec2(0.032, 0.5f),
        vec2(0.03, 0.6f),
        vec2(0.025, 0.7f),
        vec2(0.01, 0.9f),
    };

    for (int i_vert = 0; i_vert < 7; i_vert++) {
        uint v_idx = local_idx * 15 + i_vert * 2;
        gl_MeshVerticesNV[v_idx].gl_Position =
            camera_info.view_proj * vec4(grass_root_pos + vec3(sincos_xy.x * vert_info[i_vert].x, vert_info[i_vert].y, sincos_xy.y * vert_info[i_vert].x), 1.0);
        out_data[v_idx].tex_coord = vec2(1, 1);
        gl_MeshVerticesNV[v_idx+1].gl_Position =
            camera_info.view_proj * vec4(grass_root_pos + vec3(-sincos_xy.x * vert_info[i_vert].x, vert_info[i_vert].y, -sincos_xy.y * vert_info[i_vert].x), 1.0);
        out_data[v_idx+1].tex_coord = vec2(1, 1);
    }

    gl_MeshVerticesNV[local_idx * 15 + 14].gl_Position =
        camera_info.view_proj * vec4(grass_root_pos + vec3(0, 1, 0), 1.0);
    out_data[local_idx * 15 + 14].tex_coord = vec2(1, 1);

    for (int i_poly = 0; i_poly < 13; i_poly++) {
        gl_PrimitiveIndicesNV[local_idx * 39 + i_poly * 3 + 0] = local_idx * 15 + i_poly;
        gl_PrimitiveIndicesNV[local_idx * 39 + i_poly * 3 + 1] = local_idx * 15 + i_poly + 1;
        gl_PrimitiveIndicesNV[local_idx * 39 + i_poly * 3 + 2] = local_idx * 15 + i_poly + 2;
    }

    if (local_idx == 0) {
        gl_PrimitiveCountNV = 16 * 13;
    }
}
    