#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#include "global_definition.glsl.h"
#include "prt_core.glsl.h"

layout(push_constant) uniform ConemapUniformBufferObject {
    ConemapGenParams params;
};

#define kSampleAngleStep (2.0f * PI / 1024.0f)

layout(set = 0, binding = SRC_TEX_INDEX) uniform sampler2D src_img;
layout(set = 0, binding = SRC_INFO_TEX_INDEX, rg16f) uniform image2D minmax_depth_img;
layout(set = 0, binding = DST_TEX_INDEX, rgba8) uniform image2D dst_img;

float getAngle(ivec2 coords) {
	return atan(coords.y, coords.x == 0 ? 0.01f : coords.x);
}

float alignAngle(float input_angle, float reference_angle) {
    float delta_angle =
        input_angle - reference_angle;

    float result = input_angle;
    if (delta_angle > PI) {
		result = input_angle - 2.0f * PI;
	} else if (delta_angle < -PI) {
		result = input_angle + 2.0f * PI;
	}

    return result;
}

const ivec2 g_dispatch_size =
    ivec2(kConemapGenDispatchX, kConemapGenDispatchY);
const ivec2 g_cache_block_size =
    ivec2(kConemapGenBlockCacheSizeX, kConemapGenBlockCacheSizeY);

layout(local_size_x = kConemapGenDispatchX, local_size_y = kConemapGenDispatchY) in;
void main()
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 group_idx = ivec2(gl_WorkGroupID);
    ivec2 group_offset = group_idx * g_dispatch_size;
    ivec2 center_cache_block_idx = group_offset / g_cache_block_size;

    // get index in global work group i.e x,y position
    vec2 uv = (pixel_coords.xy + 0.5f) * params.inv_size;
    float c_depth = texture(src_img, uv)[params.depth_channel];

    bool skip_this_group = false;
    // if this dispatch group is with 3x3 cache blocks, means it has been processed, skip it.
    if (params.block_index.x >= center_cache_block_idx.x - 1 &&
        params.block_index.x <= center_cache_block_idx.x + 1 &&
        params.block_index.y >= center_cache_block_idx.y - 1 &&
        params.block_index.y <= center_cache_block_idx.y + 1) {
        skip_this_group = true;
    }

    ivec2 box_corner_min = params.block_offset;
    ivec2 box_corner_max = box_corner_min + g_cache_block_size - 1;
    box_corner_max = clamp(box_corner_max, ivec2(0), ivec2(params.size - 1));

    ivec2 close_dist_0 = max(group_offset - box_corner_max, ivec2(0));
    ivec2 close_dist_1 = max(box_corner_min - (group_offset + g_dispatch_size), ivec2(0));
    float closest_c_t = length(vec2(close_dist_0 + close_dist_1));

    vec2 saved_conemap_info = imageLoad(dst_img, pixel_coords).xy;
    vec2 minmax_depth = imageLoad(minmax_depth_img, params.block_index).xy;

    float buffer_diagonal_length = length(vec2(params.size));
    float inv_cone_ratio = (max(c_depth - minmax_depth.x, 0.0f) * buffer_diagonal_length) / closest_c_t;

    // if the conservative cone ratio of cached block is smaller than the saved one, skip this group.
    float inv_half_pi = 1.0f / (PI * 0.5f);
    if ((atan(inv_cone_ratio) * inv_half_pi) <= saved_conemap_info.x) {
		skip_this_group = true;
	}

    if (!skip_this_group) {
        ivec2 ray_00 = box_corner_min - ivec2(gl_GlobalInvocationID.xy);
        ivec2 ray_11 = box_corner_max - ivec2(gl_GlobalInvocationID.xy);
        ivec2 ray_01 = ivec2(ray_00.x, ray_11.y);
        ivec2 ray_10 = ivec2(ray_11.x, ray_00.y);

        float angle_00 = getAngle(ray_00);
        float angle_01 = alignAngle(getAngle(ray_01), angle_00);
        float angle_10 = alignAngle(getAngle(ray_10), angle_00);
        float angle_11 = alignAngle(getAngle(ray_11), angle_00);

        float start_angle = min(min(angle_01, angle_10), min(angle_00, angle_11));
        float end_angle = max(max(angle_01, angle_10), max(angle_00, angle_11));

        uint num_sample_rays = uint(max((end_angle - start_angle) / kSampleAngleStep, 1));

        float angle_step = (end_angle - start_angle) / float(num_sample_rays);

        vec4 best_inv_cone_ratio = vec4(0.0f);

        float alpha = start_angle + 0.5f * angle_step;
        vec2 ray_org = pixel_coords.xy + 0.5f;
        for (uint ta = 0; ta < num_sample_rays; ta++) {
            vec2 sample_ray = vec2(cos(alpha), sin(alpha));
            vec2 ray_offset = (vec2(1.0f) - sign(abs(sample_ray))) * 1e-20;
            vec2 adj_sample_ray = sample_ray + ray_offset;
            vec2 inv_sample_ray = 1.0f / adj_sample_ray;

            float adj_alpha = alpha < 0.0f ? (alpha + 2.0f * PI) : alpha;
            float zone = adj_alpha / (0.25f * PI );
            float ratio = fract(zone);
            float zone_idx = clamp(floor(zone), 0.0f, 7.0f);
            float zone_alpha_start = zone_idx * 0.25f * PI;
            float zone_alpha_end = zone_alpha_start + 0.25f * PI;

            ivec2 zone_start_offset = ivec2(round(vec2(cos(zone_alpha_start), sin(zone_alpha_start))));
            ivec2 zone_end_offset = ivec2(round(vec2(cos(zone_alpha_end), sin(zone_alpha_end))));

            vec2 t = getIntersection(ray_org, inv_sample_ray, box_corner_min, box_corner_max);
            float t_range = t.y - t.x;

            vec2 sample_ray_range = abs(t_range * sample_ray);
            uint sample_count = uint(max(max(sample_ray_range.x, sample_ray_range.y), 3.0f));

            float t_step = t_range / float(sample_count);
            vec2 sample_ray_step = sample_ray * t_step;

            float c_t = t.x + 0.5f * t_step;
            vec2 sample_ray_uv_step = sample_ray_step * params.inv_size;
            vec2 sample_uv = (ray_org + c_t * sample_ray) * params.inv_size;
            float s_d_prev = texture(src_img, sample_uv)[params.depth_channel];
            sample_uv += sample_ray_uv_step;
            float s_d = texture(src_img, sample_uv)[params.depth_channel];
            for (uint ts = 0; ts < sample_count; ts++) {
                c_t += t_step;
                sample_uv += sample_ray_uv_step;
                float s_d_next = texture(src_img, sample_uv)[params.depth_channel];

                float deta_height = s_d / c_t * t_step;
                // found tangent point.
                float inv_cone_ratio = (max(c_depth - s_d, 0.0f) * buffer_diagonal_length) / c_t;
                if (s_d_prev >= s_d - deta_height && s_d_next >= s_d + deta_height) {
                    best_inv_cone_ratio.x = max(best_inv_cone_ratio.x, inv_cone_ratio);
                }

                best_inv_cone_ratio.y = max(best_inv_cone_ratio.y, inv_cone_ratio);
	            s_d_prev = s_d;
			    s_d = s_d_next;
		    }

            alpha += angle_step;
        }

        vec4 conemap_info = vec4(
            atan(best_inv_cone_ratio.x) * inv_half_pi,
            atan(best_inv_cone_ratio.y) * inv_half_pi,
            c_depth, 0.0f);

        conemap_info.xy = max(conemap_info.xy, saved_conemap_info);

	    // output to a specific pixel in the image.
	    imageStore(dst_img, pixel_coords, conemap_info);
    }
}