#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#include "global_definition.glsl.h"
#include "prt_core.glsl.h"

layout(push_constant) uniform ConemapUniformBufferObject {
    ConemapParams params;
};

layout(set = 0, binding = SRC_TEX_INDEX) uniform sampler2D src_img;
layout(set = 0, binding = DST_TEX_INDEX, rgba8) uniform image2D dst_img;

#if USE_SHARED_MEMORY
shared float s_depth[kConemapGenBlockCacheSizeY+2][kConemapGenBlockCacheSizeX+2];
#endif

float getAngle(ivec2 coords) {
	return atan(coords.y, coords.x == 0 ? 0.01f : coords.x);
}

float alignAngle(float input_angle, float reference_angle) {
    float delta_angle =
        input_angle - reference_angle;

    float result = input_angle;
    if (delta_angle > PI) {
		result = input_angle - 2.0f * PI;
	} else if (delta_angle < -PI) {
		result = input_angle + 2.0f * PI;
	}

    return result;
}

layout(local_size_x = kConemapGenDispatchX, local_size_y = kConemapGenDispatchY) in;
void main()
{
#if USE_SHARED_MEMORY
    const int total_cache_samples = (kConemapGenBlockCacheSizeX + 2) * (kConemapGenBlockCacheSizeY + 2);
    const int dispatch_group_size = kConemapGenDispatchX * kConemapGenDispatchY;

    for (int i = int(gl_LocalInvocationIndex); i < total_cache_samples; i += dispatch_group_size) {
        int y = i / (kConemapGenBlockCacheSizeX + 2);
        int x = i % (kConemapGenBlockCacheSizeX + 2);

        ivec2 sample_coords = clamp(ivec2(x - 1, y - 1) + params.block_offset, ivec2(0), ivec2(params.size) - 1);
        vec2 sample_uv = (sample_coords.xy + 0.5f) * params.inv_size;
        s_depth[y][x] = texture(src_img, sample_uv)[params.depth_channel];
    }
    barrier();
#endif

    float start_angle = 0.0f;
    float end_angle = 2.0f * PI;
    uint num_sample_rays = (kConemapGenBlockCacheSizeY + kConemapGenBlockCacheSizeX) * 2;

    ivec2 box_corner_min = params.block_offset;
    ivec2 box_corner_max = box_corner_min + ivec2(kConemapGenBlockCacheSizeX - 1, kConemapGenBlockCacheSizeY - 1);
    box_corner_max = clamp(box_corner_max, ivec2(0), ivec2(params.size - 1));

    bool is_inside_cache =
        gl_GlobalInvocationID.x >= box_corner_min.x &&
        gl_GlobalInvocationID.y >= box_corner_min.y &&
        gl_GlobalInvocationID.x <= box_corner_max.x &&
		gl_GlobalInvocationID.y <= box_corner_max.y;

    if (!is_inside_cache) {
        ivec2 ray_00 = box_corner_min - ivec2(gl_GlobalInvocationID.xy);
        ivec2 ray_11 = box_corner_max - ivec2(gl_GlobalInvocationID.xy);
        ivec2 ray_01 = ivec2(ray_00.x, ray_11.y);
        ivec2 ray_10 = ivec2(ray_11.x, ray_00.y);

        float angle_00 = getAngle(ray_00);
        float angle_01 = alignAngle(getAngle(ray_01), angle_00);
        float angle_10 = alignAngle(getAngle(ray_10), angle_00);
        float angle_11 = alignAngle(getAngle(ray_11), angle_00);

        start_angle = min(min(angle_01, angle_10), min(angle_00, angle_11));
        end_angle = max(max(angle_01, angle_10), max(angle_00, angle_11));

        const float angle_step = 2.0f * PI / 1024.0f;
        num_sample_rays = uint((end_angle - start_angle) / angle_step) + 1;
	}

    float angle_step = (end_angle - start_angle) / float(num_sample_rays);

	// get index in global work group i.e x,y position
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (pixel_coords.xy + 0.5f) * params.inv_size;

    float c_depth = texture(src_img, uv)[params.depth_channel];
    vec4 best_inv_cone_ratio = vec4(0.0f);

    float alpha = start_angle + 0.5f * angle_step;
    float buffer_diagonal_length = length(vec2(params.size));
    for (uint ta = 0; ta < num_sample_rays; ta++) {
        vec2 sample_ray = vec2(cos(alpha), sin(alpha));
        vec2 ray_offset = (vec2(1.0f) - sign(abs(sample_ray))) * 1e-20;
        vec2 adj_sample_ray = sample_ray + ray_offset;
        vec2 inv_sample_ray = 1.0f / adj_sample_ray;

        float adj_alpha = alpha < 0.0f ? (alpha + 2.0f * PI) : alpha;
        float zone = adj_alpha / (0.25f * PI );
        float ratio = fract(zone);
        float zone_idx = clamp(floor(zone), 0.0f, 7.0f);
        float zone_alpha_start = zone_idx * 0.25f * PI;
        float zone_alpha_end = zone_alpha_start + 0.25f * PI;

        ivec2 zone_start_offset = ivec2(round(vec2(cos(zone_alpha_start), sin(zone_alpha_start))));
        ivec2 zone_end_offset = ivec2(round(vec2(cos(zone_alpha_end), sin(zone_alpha_end))));

        vec2 ray_org = pixel_coords.xy + 0.5f;
        vec2 t = getIntersection(ray_org, inv_sample_ray, box_corner_min, box_corner_max);
        float t_range = t.y - t.x;

        vec2 sample_ray_range = abs(t_range * sample_ray);
#if USE_SHARED_MEMORY
        uint sample_count = uint(max(max(sample_ray_range.x, sample_ray_range.y), 1.0f));
#else
        uint sample_count = uint(max(max(sample_ray_range.x, sample_ray_range.y), 3.0f));
#endif

        float t_step = t_range / float(sample_count);
        vec2 sample_ray_step = sample_ray * t_step;

#if USE_SHARED_MEMORY
        float sample_t_step = length(mix(vec2(zone_start_offset), vec2(zone_end_offset), ratio));
        float c_t = t.x + 0.5f * t_step;
        vec2 sample_offset = ray_org - box_corner_min;
        for (uint ts = 0; ts < sample_count; ts++) {
            vec2 c_position = sample_offset + c_t * sample_ray;
            ivec2 sample_coords =
                clamp(ivec2(c_position), ivec2(0), ivec2(kConemapGenBlockCacheSizeX, kConemapGenBlockCacheSizeY) - 1) + 1;
            float s_d = s_depth[sample_coords.y][sample_coords.x];
            float s_d_next = mix(s_depth[sample_coords.y + zone_start_offset.y][sample_coords.x + zone_start_offset.x],
                                 s_depth[sample_coords.y + zone_end_offset.y][sample_coords.x + zone_end_offset.x],
                                 ratio);
            float s_d_prev = mix(s_depth[sample_coords.y - zone_start_offset.y][sample_coords.x - zone_start_offset.x],
                                 s_depth[sample_coords.y - zone_end_offset.y][sample_coords.x - zone_end_offset.x],
                                 ratio);

            float deta_height = s_d / c_t * sample_t_step;
            // found tangent point.
            float inv_cone_ratio = (max(c_depth - s_d, 0.0f) * buffer_diagonal_length) / c_t;
            if (s_d_prev >= s_d - deta_height && s_d_next >= s_d + deta_height) {
                    best_inv_cone_ratio.x = max(best_inv_cone_ratio.x, inv_cone_ratio);
            }

            best_inv_cone_ratio.y = max(best_inv_cone_ratio.y, inv_cone_ratio);
			c_t += t_step;
		}
#else
        float c_t = t.x + 0.5f * t_step;
        vec2 sample_offset = ray_org - box_corner_min;
        vec2 sample_ray_uv_step = sample_ray_step * params.inv_size;
        vec2 sample_uv = (sample_offset + c_t * sample_ray) * params.inv_size;
        float s_d_prev = texture(src_img, sample_uv)[params.depth_channel];
        sample_uv += sample_ray_uv_step;
        float s_d = texture(src_img, sample_uv)[params.depth_channel];
        for (uint ts = 0; ts < sample_count; ts++) {
            c_t += t_step;
            sample_uv += sample_ray_uv_step;
            float s_d_next = texture(src_img, sample_uv)[params.depth_channel];

            float deta_height = s_d / c_t * t_step;
            // found tangent point.
            float inv_cone_ratio = (max(c_depth - s_d, 0.0f) * buffer_diagonal_length) / c_t;
            if (s_d_prev >= s_d - deta_height && s_d_next >= s_d + deta_height) {
                best_inv_cone_ratio.x = max(best_inv_cone_ratio.x, inv_cone_ratio);
            }

            best_inv_cone_ratio.y = max(best_inv_cone_ratio.y, inv_cone_ratio);
	        s_d_prev = s_d;
			s_d = s_d_next;
		}
#endif
        alpha += angle_step;
    }

    float inv_half_pi = 1.0f / (PI * 0.5f);

    vec4 conemap_info = vec4(
        atan(best_inv_cone_ratio.x) * inv_half_pi,
        atan(best_inv_cone_ratio.y) * inv_half_pi,
        c_depth, 1.0f);

    if (params.block_offset.x != 0 || params.block_offset.y != 0) {
        vec2 saved_conemap_info = imageLoad(dst_img, pixel_coords).xy;
        conemap_info.xy = max(conemap_info.xy, saved_conemap_info);
    }

	// output to a specific pixel in the image.
	imageStore(dst_img, pixel_coords, conemap_info);
}