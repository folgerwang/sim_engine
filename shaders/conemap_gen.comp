#version 450
#extension GL_ARB_separate_shader_objects : enable
#include "global_definition.glsl.h"
#include "prt_core.glsl.h"

layout(push_constant) uniform ConemapUniformBufferObject {
    ConemapParams params;
};

layout(set = 0, binding = SRC_TEX_INDEX) uniform sampler2D src_img;
layout(set = 0, binding = DST_TEX_INDEX, rgba8) uniform image2D dst_img;

layout(local_size_x = 8, local_size_y = 8) in;
void main()
{
	// get index in global work group i.e x,y position
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (pixel_coords.xy + 0.5f) * params.inv_size;

	vec3 ray_origin = vec3(uv, 0.0f);
    float c_depth = texture(src_img, uv)[params.depth_channel];
    const uint search_steps = 128;
    vec4 best_inv_cone_ratio = vec4(0.0f);

#if 0
    for (uint ty = 0; ty < params.size.y; ty++) {
        for (uint tx = 0; tx < params.size.x; tx++) {
            if (tx != pixel_coords.x && ty != pixel_coords.y) {
                vec2 sample_uv = (vec2(tx, ty) + 0.5f) * params.inv_size;
                vec3 lookup_pos = vec3(sample_uv, texture(src_img, sample_uv)[params.depth_channel]);
                vec3 v = lookup_pos - ray_origin;
                if (v.z > 0.0f) {
                    v /= v.z;
                }
                v *= 1.0f - lookup_pos.z;
                v /= float(search_steps);
                vec3 p = lookup_pos + v;
                for (int i = 0; i < search_steps -1; i++) {
                    float d = texture(src_img, p.xy)[params.depth_channel];
                    if (d < p.z) {
                        p += v;
                    }
                }

                float sample_dist = length(clamp(p.xy, 0.0f, 1.0f) - uv);
                float inv_cone_ratio = max(c_depth - p.z, 0.0f) / sample_dist;
                if (best_inv_cone_ratio.x < inv_cone_ratio)
                {
                    best_inv_cone_ratio.x = inv_cone_ratio;
                }

                sample_dist = length(clamp(lookup_pos.xy, 0.0f, 1.0f) - uv);
                inv_cone_ratio = max(c_depth - lookup_pos.z, 0.0f) / sample_dist;
                if (best_inv_cone_ratio.y < inv_cone_ratio)
                {
                    best_inv_cone_ratio.y = inv_cone_ratio;
                }
            }
        }
    }
#else
    const uint MAX_SAMPLES = 1024;
    uint valid_size = max(params.size.x, params.size.y);
    for (uint ta = 0; ta < MAX_SAMPLES; ta++) {
        float alpha = (ta + 0.5f) / MAX_SAMPLES * 2.0f * PI;
        vec2 sample_ray = vec2(cos(alpha), sin(alpha));
        float max_t = getIntersection(vec2(ray_origin) * 2.0f - 1.0f, sample_ray) * 0.5f;
        if (max_t > 0.5f / valid_size) { // larger than half pixel.
            uint sample_count = max(uint(max_t * valid_size), 3);

            float step_t = max_t / sample_count;
            vec2 step_ray = step_t * sample_ray;

            vec4 sample0, sample1, sample2;
            sample0.xy = ray_origin.xy + step_ray * 0.5f;
            sample0.z = texture(src_img, sample0.xy)[params.depth_channel];
            sample0.w = step_t * 0.5f;
            sample1.xy = sample0.xy + step_ray;
            sample1.z = texture(src_img, sample1.xy)[params.depth_channel];
            sample1.w = sample0.w + step_t;

            for (uint i = 0; i < sample_count - 2; i++) {
                sample2.xy = sample1.xy + step_ray;
                sample2.z = texture(src_img, sample2.xy)[params.depth_channel];
                sample2.w = sample1.w + step_t;

                float deta_height = sample1.z / sample1.w * step_t;
                // sample0 and sample2 is below tangent plane created by ray origin and sample1.
                float inv_cone_ratio = max(c_depth - sample1.z, 0.0f) / sample1.w;
                if (sample0.z >= sample1.z - deta_height && sample2.z >= sample1.z + deta_height) {
                    best_inv_cone_ratio = max(best_inv_cone_ratio, inv_cone_ratio);
                }

                best_inv_cone_ratio.y = max(best_inv_cone_ratio.y, inv_cone_ratio);

                sample0 = sample1;
                sample1 = sample2;
            }
        }

        if (best_inv_cone_ratio.x == 0.0f) {
            best_inv_cone_ratio.x = best_inv_cone_ratio.y;
        }
    }
#endif

    float inv_half_pi = 1.0f / (PI * 0.5f);

    vec4 conemap_info = vec4(
        atan(best_inv_cone_ratio.x) * inv_half_pi,
        atan(best_inv_cone_ratio.y) * inv_half_pi,
        c_depth, 1.0f);

	// output to a specific pixel in the image.
	imageStore(dst_img, pixel_coords, conemap_info);
}