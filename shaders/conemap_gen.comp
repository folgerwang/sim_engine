#version 450
#extension GL_ARB_separate_shader_objects : enable
#include "global_definition.glsl.h"

layout(push_constant) uniform ConemapUniformBufferObject {
    ConemapParams params;
};

layout(set = 0, binding = SRC_TEX_INDEX) uniform sampler2D src_img;
layout(set = 0, binding = DST_TEX_INDEX, rgba8) uniform image2D dst_img;

layout(local_size_x = 8, local_size_y = 8) in;
void main()
{
	// get index in global work group i.e x,y position
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = (pixel_coords.xy + 0.5f) * params.inv_size;

	vec3 ray_origin = vec3(uv, 0.0f);
    float c_depth = texture(src_img, uv).w;
    const uint search_steps = 128;
    vec4 best_inv_cone_ratio = vec4(0.0f);

    for (uint ty = 0; ty < params.size.y; ty++) {
        for (uint tx = 0; tx < params.size.x; tx++) {
            if (tx != pixel_coords.x && ty != pixel_coords.y) {
                vec2 sample_uv = (vec2(tx, ty) + 0.5f) * params.inv_size;
                vec3 lookup_pos = vec3(sample_uv, texture(src_img, sample_uv).w);
                vec3 v = lookup_pos - ray_origin;
                if (v.z > 0.0f) {
                    v /= v.z;
                }
                v *= 1.0f - lookup_pos.z;
                v /= float(search_steps);
                vec3 p = lookup_pos + v;
                for (int i = 0; i < search_steps -1; i++) {
                    float d = texture(src_img, p.xy).w;
                    if (d < p.z) {
                        p += v;
                    }
                }

                float sample_dist = length(clamp(p.xy, 0.0f, 1.0f) - uv);
                float inv_cone_ratio = max(c_depth - p.z, 0.0f) / sample_dist;
                if (best_inv_cone_ratio.x < inv_cone_ratio)
                {
                    best_inv_cone_ratio.x = inv_cone_ratio;
                }

                sample_dist = length(clamp(lookup_pos.xy, 0.0f, 1.0f) - uv);
                inv_cone_ratio = max(c_depth - lookup_pos.z, 0.0f) / sample_dist;
                if (best_inv_cone_ratio.y < inv_cone_ratio)
                {
                    best_inv_cone_ratio.y = inv_cone_ratio;
                }
            }
        }
    }

    float inv_half_pi = 1.0f / (PI * 0.5f);

    vec4 conemap_info = vec4(
        atan(best_inv_cone_ratio.x) * inv_half_pi,
        atan(best_inv_cone_ratio.y) * inv_half_pi,
        c_depth, 1.0f);

	// output to a specific pixel in the image.
	imageStore(dst_img, pixel_coords, conemap_info);
}