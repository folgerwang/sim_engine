#include <iostream>
#include <set>
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "../renderer.h"
#include "vk_device.h"
#include "vk_command_buffer.h"
#include "vk_renderer_helper.h"

namespace engine {
namespace renderer {
namespace vk {

PFN_vkGetBufferDeviceAddressKHR vkGetBufferDeviceAddressKHR;
PFN_vkCreateAccelerationStructureKHR vkCreateAccelerationStructureKHR;
PFN_vkDestroyAccelerationStructureKHR vkDestroyAccelerationStructureKHR;
PFN_vkGetAccelerationStructureBuildSizesKHR vkGetAccelerationStructureBuildSizesKHR;
PFN_vkGetAccelerationStructureDeviceAddressKHR vkGetAccelerationStructureDeviceAddressKHR;
PFN_vkCmdBuildAccelerationStructuresKHR vkCmdBuildAccelerationStructuresKHR;
PFN_vkBuildAccelerationStructuresKHR vkBuildAccelerationStructuresKHR;
PFN_vkCmdTraceRaysKHR vkCmdTraceRaysKHR;
PFN_vkGetRayTracingShaderGroupHandlesKHR vkGetRayTracingShaderGroupHandlesKHR;
PFN_vkCreateRayTracingPipelinesKHR vkCreateRayTracingPipelinesKHR;

namespace helper {

static uint32_t max_vertex_input_attribute_offset = 0;
const std::vector<const char*> validation_layers = {
    "VK_LAYER_KHRONOS_validation",
};

const std::vector<const char*> device_extensions = {
    VK_KHR_SWAPCHAIN_EXTENSION_NAME,
    VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME,
    VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME,
    VK_KHR_MAINTENANCE3_EXTENSION_NAME,
    VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME,
    VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME,
    VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME,
    VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME,
    VK_KHR_SPIRV_1_4_EXTENSION_NAME,
    VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME,
    VK_KHR_DEVICE_GROUP_EXTENSION_NAME
};

#ifdef NDEBUG
static bool s_enable_validation_layers = false;
#else
static bool s_enable_validation_layers = true;
#endif

bool hasEnabledValidationLayers() {
    return s_enable_validation_layers;
}

VkFormat toVkFormat(renderer::Format format) {
    auto flag = format;
    SELECT_FLAG(Format, FORMAT, R4G4_UNORM_PACK8);
    SELECT_FLAG(Format, FORMAT, R4G4B4A4_UNORM_PACK16);
    SELECT_FLAG(Format, FORMAT, B4G4R4A4_UNORM_PACK16);
    SELECT_FLAG(Format, FORMAT, R5G6B5_UNORM_PACK16);
    SELECT_FLAG(Format, FORMAT, B5G6R5_UNORM_PACK16);
    SELECT_FLAG(Format, FORMAT, R5G5B5A1_UNORM_PACK16);
    SELECT_FLAG(Format, FORMAT, B5G5R5A1_UNORM_PACK16);
    SELECT_FLAG(Format, FORMAT, A1R5G5B5_UNORM_PACK16);
    SELECT_FLAG(Format, FORMAT, R8_UNORM);
    SELECT_FLAG(Format, FORMAT, R8_SNORM);
    SELECT_FLAG(Format, FORMAT, R8_USCALED);
    SELECT_FLAG(Format, FORMAT, R8_SSCALED);
    SELECT_FLAG(Format, FORMAT, R8_UINT);
    SELECT_FLAG(Format, FORMAT, R8_SINT);
    SELECT_FLAG(Format, FORMAT, R8_SRGB);
    SELECT_FLAG(Format, FORMAT, R8G8_UNORM);
    SELECT_FLAG(Format, FORMAT, R8G8_SNORM);
    SELECT_FLAG(Format, FORMAT, R8G8_USCALED);
    SELECT_FLAG(Format, FORMAT, R8G8_SSCALED);
    SELECT_FLAG(Format, FORMAT, R8G8_UINT);
    SELECT_FLAG(Format, FORMAT, R8G8_SINT);
    SELECT_FLAG(Format, FORMAT, R8G8_SRGB);
    SELECT_FLAG(Format, FORMAT, R8G8B8_UNORM);
    SELECT_FLAG(Format, FORMAT, R8G8B8_SNORM);
    SELECT_FLAG(Format, FORMAT, R8G8B8_USCALED);
    SELECT_FLAG(Format, FORMAT, R8G8B8_SSCALED);
    SELECT_FLAG(Format, FORMAT, R8G8B8_UINT);
    SELECT_FLAG(Format, FORMAT, R8G8B8_SINT);
    SELECT_FLAG(Format, FORMAT, R8G8B8_SRGB);
    SELECT_FLAG(Format, FORMAT, B8G8R8_UNORM);
    SELECT_FLAG(Format, FORMAT, B8G8R8_SNORM);
    SELECT_FLAG(Format, FORMAT, B8G8R8_USCALED);
    SELECT_FLAG(Format, FORMAT, B8G8R8_SSCALED);
    SELECT_FLAG(Format, FORMAT, B8G8R8_UINT);
    SELECT_FLAG(Format, FORMAT, B8G8R8_SINT);
    SELECT_FLAG(Format, FORMAT, B8G8R8_SRGB);
    SELECT_FLAG(Format, FORMAT, R8G8B8A8_UNORM);
    SELECT_FLAG(Format, FORMAT, R8G8B8A8_SNORM);
    SELECT_FLAG(Format, FORMAT, R8G8B8A8_USCALED);
    SELECT_FLAG(Format, FORMAT, R8G8B8A8_SSCALED);
    SELECT_FLAG(Format, FORMAT, R8G8B8A8_UINT);
    SELECT_FLAG(Format, FORMAT, R8G8B8A8_SINT);
    SELECT_FLAG(Format, FORMAT, R8G8B8A8_SRGB);
    SELECT_FLAG(Format, FORMAT, B8G8R8A8_UNORM);
    SELECT_FLAG(Format, FORMAT, B8G8R8A8_SNORM);
    SELECT_FLAG(Format, FORMAT, B8G8R8A8_USCALED);
    SELECT_FLAG(Format, FORMAT, B8G8R8A8_SSCALED);
    SELECT_FLAG(Format, FORMAT, B8G8R8A8_UINT);
    SELECT_FLAG(Format, FORMAT, B8G8R8A8_SINT);
    SELECT_FLAG(Format, FORMAT, B8G8R8A8_SRGB);
    SELECT_FLAG(Format, FORMAT, A8B8G8R8_UNORM_PACK32);
    SELECT_FLAG(Format, FORMAT, A8B8G8R8_SNORM_PACK32);
    SELECT_FLAG(Format, FORMAT, A8B8G8R8_USCALED_PACK32);
    SELECT_FLAG(Format, FORMAT, A8B8G8R8_SSCALED_PACK32);
    SELECT_FLAG(Format, FORMAT, A8B8G8R8_UINT_PACK32);
    SELECT_FLAG(Format, FORMAT, A8B8G8R8_SINT_PACK32);
    SELECT_FLAG(Format, FORMAT, A8B8G8R8_SRGB_PACK32);
    SELECT_FLAG(Format, FORMAT, A2R10G10B10_UNORM_PACK32);
    SELECT_FLAG(Format, FORMAT, A2R10G10B10_SNORM_PACK32);
    SELECT_FLAG(Format, FORMAT, A2R10G10B10_USCALED_PACK32);
    SELECT_FLAG(Format, FORMAT, A2R10G10B10_SSCALED_PACK32);
    SELECT_FLAG(Format, FORMAT, A2R10G10B10_UINT_PACK32);
    SELECT_FLAG(Format, FORMAT, A2R10G10B10_SINT_PACK32);
    SELECT_FLAG(Format, FORMAT, A2B10G10R10_UNORM_PACK32);
    SELECT_FLAG(Format, FORMAT, A2B10G10R10_SNORM_PACK32);
    SELECT_FLAG(Format, FORMAT, A2B10G10R10_USCALED_PACK32);
    SELECT_FLAG(Format, FORMAT, A2B10G10R10_SSCALED_PACK32);
    SELECT_FLAG(Format, FORMAT, A2B10G10R10_UINT_PACK32);
    SELECT_FLAG(Format, FORMAT, A2B10G10R10_SINT_PACK32);
    SELECT_FLAG(Format, FORMAT, R16_UNORM);
    SELECT_FLAG(Format, FORMAT, R16_SNORM);
    SELECT_FLAG(Format, FORMAT, R16_USCALED);
    SELECT_FLAG(Format, FORMAT, R16_SSCALED);
    SELECT_FLAG(Format, FORMAT, R16_UINT);
    SELECT_FLAG(Format, FORMAT, R16_SINT);
    SELECT_FLAG(Format, FORMAT, R16_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R16G16_UNORM);
    SELECT_FLAG(Format, FORMAT, R16G16_SNORM);
    SELECT_FLAG(Format, FORMAT, R16G16_USCALED);
    SELECT_FLAG(Format, FORMAT, R16G16_SSCALED);
    SELECT_FLAG(Format, FORMAT, R16G16_UINT);
    SELECT_FLAG(Format, FORMAT, R16G16_SINT);
    SELECT_FLAG(Format, FORMAT, R16G16_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R16G16B16_UNORM);
    SELECT_FLAG(Format, FORMAT, R16G16B16_SNORM);
    SELECT_FLAG(Format, FORMAT, R16G16B16_USCALED);
    SELECT_FLAG(Format, FORMAT, R16G16B16_SSCALED);
    SELECT_FLAG(Format, FORMAT, R16G16B16_UINT);
    SELECT_FLAG(Format, FORMAT, R16G16B16_SINT);
    SELECT_FLAG(Format, FORMAT, R16G16B16_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R16G16B16A16_UNORM);
    SELECT_FLAG(Format, FORMAT, R16G16B16A16_SNORM);
    SELECT_FLAG(Format, FORMAT, R16G16B16A16_USCALED);
    SELECT_FLAG(Format, FORMAT, R16G16B16A16_SSCALED);
    SELECT_FLAG(Format, FORMAT, R16G16B16A16_UINT);
    SELECT_FLAG(Format, FORMAT, R16G16B16A16_SINT);
    SELECT_FLAG(Format, FORMAT, R16G16B16A16_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R32_UINT);
    SELECT_FLAG(Format, FORMAT, R32_SINT);
    SELECT_FLAG(Format, FORMAT, R32_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R32G32_UINT);
    SELECT_FLAG(Format, FORMAT, R32G32_SINT);
    SELECT_FLAG(Format, FORMAT, R32G32_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R32G32B32_UINT);
    SELECT_FLAG(Format, FORMAT, R32G32B32_SINT);
    SELECT_FLAG(Format, FORMAT, R32G32B32_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R32G32B32A32_UINT);
    SELECT_FLAG(Format, FORMAT, R32G32B32A32_SINT);
    SELECT_FLAG(Format, FORMAT, R32G32B32A32_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R64_UINT);
    SELECT_FLAG(Format, FORMAT, R64_SINT);
    SELECT_FLAG(Format, FORMAT, R64_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R64G64_UINT);
    SELECT_FLAG(Format, FORMAT, R64G64_SINT);
    SELECT_FLAG(Format, FORMAT, R64G64_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R64G64B64_UINT);
    SELECT_FLAG(Format, FORMAT, R64G64B64_SINT);
    SELECT_FLAG(Format, FORMAT, R64G64B64_SFLOAT);
    SELECT_FLAG(Format, FORMAT, R64G64B64A64_UINT);
    SELECT_FLAG(Format, FORMAT, R64G64B64A64_SINT);
    SELECT_FLAG(Format, FORMAT, R64G64B64A64_SFLOAT);
    SELECT_FLAG(Format, FORMAT, B10G11R11_UFLOAT_PACK32);
    SELECT_FLAG(Format, FORMAT, E5B9G9R9_UFLOAT_PACK32);
    SELECT_FLAG(Format, FORMAT, D16_UNORM);
    SELECT_FLAG(Format, FORMAT, X8_D24_UNORM_PACK32);
    SELECT_FLAG(Format, FORMAT, D32_SFLOAT);
    SELECT_FLAG(Format, FORMAT, S8_UINT);
    SELECT_FLAG(Format, FORMAT, D16_UNORM_S8_UINT);
    SELECT_FLAG(Format, FORMAT, D24_UNORM_S8_UINT);
    SELECT_FLAG(Format, FORMAT, D32_SFLOAT_S8_UINT);
    SELECT_FLAG(Format, FORMAT, BC1_RGB_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC1_RGB_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC1_RGBA_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC1_RGBA_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC2_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC2_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC3_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC3_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC4_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC4_SNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC5_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC5_SNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC6H_UFLOAT_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC6H_SFLOAT_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC7_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, BC7_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ETC2_R8G8B8_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ETC2_R8G8B8_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ETC2_R8G8B8A1_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ETC2_R8G8B8A1_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ETC2_R8G8B8A8_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ETC2_R8G8B8A8_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, EAC_R11_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, EAC_R11_SNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, EAC_R11G11_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, EAC_R11G11_SNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_4x4_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_4x4_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_5x4_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_5x4_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_5x5_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_5x5_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_6x5_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_6x5_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_6x6_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_6x6_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_8x5_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_8x5_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_8x6_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_8x6_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_8x8_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_8x8_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_10x5_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_10x5_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_10x6_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_10x6_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_10x8_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_10x8_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_10x10_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_10x10_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_12x10_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_12x10_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_12x12_UNORM_BLOCK);
    SELECT_FLAG(Format, FORMAT, ASTC_12x12_SRGB_BLOCK);
    SELECT_FLAG(Format, FORMAT, G8B8G8R8_422_UNORM);
    SELECT_FLAG(Format, FORMAT, B8G8R8G8_422_UNORM);
    SELECT_FLAG(Format, FORMAT, G8_B8_R8_3PLANE_420_UNORM);
    SELECT_FLAG(Format, FORMAT, G8_B8R8_2PLANE_420_UNORM);
    SELECT_FLAG(Format, FORMAT, G8_B8_R8_3PLANE_422_UNORM);
    SELECT_FLAG(Format, FORMAT, G8_B8R8_2PLANE_422_UNORM);
    SELECT_FLAG(Format, FORMAT, G8_B8_R8_3PLANE_444_UNORM);
    SELECT_FLAG(Format, FORMAT, R10X6_UNORM_PACK16);
    SELECT_FLAG(Format, FORMAT, R10X6G10X6_UNORM_2PACK16);
    SELECT_FLAG(Format, FORMAT, G10X6B10X6G10X6R10X6_422_UNORM_4PACK16);
    SELECT_FLAG(Format, FORMAT, B10X6G10X6R10X6G10X6_422_UNORM_4PACK16);
    SELECT_FLAG(Format, FORMAT, G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16);
    SELECT_FLAG(Format, FORMAT, G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16);
    SELECT_FLAG(Format, FORMAT, G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16);
    SELECT_FLAG(Format, FORMAT, G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16);
    SELECT_FLAG(Format, FORMAT, G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16);
    SELECT_FLAG(Format, FORMAT, R12X4_UNORM_PACK16);
    SELECT_FLAG(Format, FORMAT, R12X4G12X4_UNORM_2PACK16);
    SELECT_FLAG(Format, FORMAT, R12X4G12X4B12X4A12X4_UNORM_4PACK16);
    SELECT_FLAG(Format, FORMAT, G12X4B12X4G12X4R12X4_422_UNORM_4PACK16);
    SELECT_FLAG(Format, FORMAT, B12X4G12X4R12X4G12X4_422_UNORM_4PACK16);
    SELECT_FLAG(Format, FORMAT, G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16);
    SELECT_FLAG(Format, FORMAT, G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16);
    SELECT_FLAG(Format, FORMAT, G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16);
    SELECT_FLAG(Format, FORMAT, G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16);
    SELECT_FLAG(Format, FORMAT, G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16);
    SELECT_FLAG(Format, FORMAT, G16B16G16R16_422_UNORM);
    SELECT_FLAG(Format, FORMAT, B16G16R16G16_422_UNORM);
    SELECT_FLAG(Format, FORMAT, G16_B16_R16_3PLANE_420_UNORM);
    SELECT_FLAG(Format, FORMAT, G16_B16R16_2PLANE_420_UNORM);
    SELECT_FLAG(Format, FORMAT, G16_B16_R16_3PLANE_422_UNORM);
    SELECT_FLAG(Format, FORMAT, G16_B16R16_2PLANE_422_UNORM);
    SELECT_FLAG(Format, FORMAT, G16_B16_R16_3PLANE_444_UNORM);
    SELECT_FLAG(Format, FORMAT, PVRTC1_2BPP_UNORM_BLOCK_IMG);
    SELECT_FLAG(Format, FORMAT, PVRTC1_4BPP_UNORM_BLOCK_IMG);
    SELECT_FLAG(Format, FORMAT, PVRTC2_2BPP_UNORM_BLOCK_IMG);
    SELECT_FLAG(Format, FORMAT, PVRTC2_4BPP_UNORM_BLOCK_IMG);
    SELECT_FLAG(Format, FORMAT, PVRTC1_2BPP_SRGB_BLOCK_IMG);
    SELECT_FLAG(Format, FORMAT, PVRTC1_4BPP_SRGB_BLOCK_IMG);
    SELECT_FLAG(Format, FORMAT, PVRTC2_2BPP_SRGB_BLOCK_IMG);
    SELECT_FLAG(Format, FORMAT, PVRTC2_4BPP_SRGB_BLOCK_IMG);
    SELECT_FLAG(Format, FORMAT, ASTC_4x4_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_5x4_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_5x5_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_6x5_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_6x6_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_8x5_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_8x6_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_10x5_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_10x6_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_10x8_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_10x10_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_12x10_SFLOAT_BLOCK_EXT);
    SELECT_FLAG(Format, FORMAT, ASTC_12x12_SFLOAT_BLOCK_EXT);
    return VK_FORMAT_UNDEFINED;
}

renderer::Format fromVkFormat(VkFormat format) {
    auto flag = format;
    SELECT_FROM_FLAG(Format, FORMAT, R4G4_UNORM_PACK8);
    SELECT_FROM_FLAG(Format, FORMAT, R4G4B4A4_UNORM_PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, B4G4R4A4_UNORM_PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, R5G6B5_UNORM_PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, B5G6R5_UNORM_PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, R5G5B5A1_UNORM_PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, B5G5R5A1_UNORM_PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, A1R5G5B5_UNORM_PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, R8_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R8_SNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R8_USCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R8_SSCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R8_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R8_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R8_SRGB);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8_SNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8_USCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8_SSCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8_SRGB);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8_SNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8_USCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8_SSCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8_SRGB);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8_SNORM);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8_USCALED);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8_SSCALED);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8_SRGB);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8A8_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8A8_SNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8A8_USCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8A8_SSCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8A8_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8A8_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R8G8B8A8_SRGB);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8A8_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8A8_SNORM);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8A8_USCALED);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8A8_SSCALED);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8A8_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8A8_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8A8_SRGB);
    SELECT_FROM_FLAG(Format, FORMAT, A8B8G8R8_UNORM_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A8B8G8R8_SNORM_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A8B8G8R8_USCALED_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A8B8G8R8_SSCALED_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A8B8G8R8_UINT_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A8B8G8R8_SINT_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A8B8G8R8_SRGB_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2R10G10B10_UNORM_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2R10G10B10_SNORM_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2R10G10B10_USCALED_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2R10G10B10_SSCALED_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2R10G10B10_UINT_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2R10G10B10_SINT_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2B10G10R10_UNORM_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2B10G10R10_SNORM_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2B10G10R10_USCALED_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2B10G10R10_SSCALED_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2B10G10R10_UINT_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, A2B10G10R10_SINT_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, R16_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R16_SNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R16_USCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R16_SSCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R16_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R16_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R16_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16_SNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16_USCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16_SSCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16_SNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16_USCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16_SSCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16A16_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16A16_SNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16A16_USCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16A16_SSCALED);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16A16_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16A16_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R16G16B16A16_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R32_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R32_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R32_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R32G32_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R32G32_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R32G32_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R32G32B32_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R32G32B32_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R32G32B32_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R32G32B32A32_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R32G32B32A32_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R32G32B32A32_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R64_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R64_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R64_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R64G64_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R64G64_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R64G64_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R64G64B64_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R64G64B64_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R64G64B64_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, R64G64B64A64_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, R64G64B64A64_SINT);
    SELECT_FROM_FLAG(Format, FORMAT, R64G64B64A64_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, B10G11R11_UFLOAT_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, E5B9G9R9_UFLOAT_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, D16_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, X8_D24_UNORM_PACK32);
    SELECT_FROM_FLAG(Format, FORMAT, D32_SFLOAT);
    SELECT_FROM_FLAG(Format, FORMAT, S8_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, D16_UNORM_S8_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, D24_UNORM_S8_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, D32_SFLOAT_S8_UINT);
    SELECT_FROM_FLAG(Format, FORMAT, BC1_RGB_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC1_RGB_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC1_RGBA_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC1_RGBA_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC2_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC2_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC3_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC3_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC4_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC4_SNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC5_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC5_SNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC6H_UFLOAT_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC6H_SFLOAT_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC7_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, BC7_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ETC2_R8G8B8_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ETC2_R8G8B8_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ETC2_R8G8B8A1_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ETC2_R8G8B8A1_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ETC2_R8G8B8A8_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ETC2_R8G8B8A8_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, EAC_R11_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, EAC_R11_SNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, EAC_R11G11_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, EAC_R11G11_SNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_4x4_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_4x4_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_5x4_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_5x4_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_5x5_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_5x5_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_6x5_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_6x5_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_6x6_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_6x6_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_8x5_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_8x5_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_8x6_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_8x6_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_8x8_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_8x8_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x5_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x5_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x6_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x6_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x8_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x8_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x10_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x10_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_12x10_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_12x10_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_12x12_UNORM_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_12x12_SRGB_BLOCK);
    SELECT_FROM_FLAG(Format, FORMAT, G8B8G8R8_422_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, B8G8R8G8_422_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, G8_B8_R8_3PLANE_420_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, G8_B8R8_2PLANE_420_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, G8_B8_R8_3PLANE_422_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, G8_B8R8_2PLANE_422_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, G8_B8_R8_3PLANE_444_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, R10X6_UNORM_PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, R10X6G10X6_UNORM_2PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G10X6B10X6G10X6R10X6_422_UNORM_4PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, B10X6G10X6R10X6G10X6_422_UNORM_4PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, R12X4_UNORM_PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, R12X4G12X4_UNORM_2PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, R12X4G12X4B12X4A12X4_UNORM_4PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G12X4B12X4G12X4R12X4_422_UNORM_4PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, B12X4G12X4R12X4G12X4_422_UNORM_4PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16);
    SELECT_FROM_FLAG(Format, FORMAT, G16B16G16R16_422_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, B16G16R16G16_422_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, G16_B16_R16_3PLANE_420_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, G16_B16R16_2PLANE_420_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, G16_B16_R16_3PLANE_422_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, G16_B16R16_2PLANE_422_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, G16_B16_R16_3PLANE_444_UNORM);
    SELECT_FROM_FLAG(Format, FORMAT, PVRTC1_2BPP_UNORM_BLOCK_IMG);
    SELECT_FROM_FLAG(Format, FORMAT, PVRTC1_4BPP_UNORM_BLOCK_IMG);
    SELECT_FROM_FLAG(Format, FORMAT, PVRTC2_2BPP_UNORM_BLOCK_IMG);
    SELECT_FROM_FLAG(Format, FORMAT, PVRTC2_4BPP_UNORM_BLOCK_IMG);
    SELECT_FROM_FLAG(Format, FORMAT, PVRTC1_2BPP_SRGB_BLOCK_IMG);
    SELECT_FROM_FLAG(Format, FORMAT, PVRTC1_4BPP_SRGB_BLOCK_IMG);
    SELECT_FROM_FLAG(Format, FORMAT, PVRTC2_2BPP_SRGB_BLOCK_IMG);
    SELECT_FROM_FLAG(Format, FORMAT, PVRTC2_4BPP_SRGB_BLOCK_IMG);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_4x4_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_5x4_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_5x5_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_6x5_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_6x6_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_8x5_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_8x6_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x5_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x6_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x8_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_10x10_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_12x10_SFLOAT_BLOCK_EXT);
    SELECT_FROM_FLAG(Format, FORMAT, ASTC_12x12_SFLOAT_BLOCK_EXT);
    return renderer::Format::UNDEFINED;
}

VkBufferUsageFlags toVkBufferUsageFlags(renderer::BufferUsageFlags flags) {
    VkBufferUsageFlags result = 0;
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, TRANSFER_SRC_BIT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, TRANSFER_DST_BIT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, UNIFORM_TEXEL_BUFFER_BIT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, STORAGE_TEXEL_BUFFER_BIT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, UNIFORM_BUFFER_BIT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, STORAGE_BUFFER_BIT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, INDEX_BUFFER_BIT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, VERTEX_BUFFER_BIT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, INDIRECT_BUFFER_BIT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, SHADER_DEVICE_ADDRESS_BIT);
#ifdef ENABLE_BETA_EXTENSIONS
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, VIDEO_DECODE_SRC_BIT_KHR);
#endif
#ifdef ENABLE_BETA_EXTENSIONS
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, VIDEO_DECODE_DST_BIT_KHR);
#endif
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, TRANSFORM_FEEDBACK_BUFFER_BIT_EXT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, CONDITIONAL_RENDERING_BIT_EXT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, ACCELERATION_STRUCTURE_STORAGE_BIT_KHR);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, SHADER_BINDING_TABLE_BIT_KHR);
#ifdef ENABLE_BETA_EXTENSIONS
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, VIDEO_ENCODE_DST_BIT_KHR);
#endif
#ifdef ENABLE_BETA_EXTENSIONS
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, VIDEO_ENCODE_SRC_BIT_KHR);
#endif
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, RAY_TRACING_BIT_NV);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, SHADER_DEVICE_ADDRESS_BIT_EXT);
    ADD_FLAG_BIT(BufferUsage, BUFFER_USAGE, SHADER_DEVICE_ADDRESS_BIT_KHR);

    return result;
}

VkMemoryAllocateFlags toVkMemoryAllocateFlags(renderer::MemoryAllocateFlags flags) {
    VkMemoryAllocateFlags result = 0;
    ADD_FLAG_BIT(MemoryAllocate, MEMORY_ALLOCATE, DEVICE_MASK_BIT);
    ADD_FLAG_BIT(MemoryAllocate, MEMORY_ALLOCATE, DEVICE_ADDRESS_BIT);
    ADD_FLAG_BIT(MemoryAllocate, MEMORY_ALLOCATE, DEVICE_ADDRESS_CAPTURE_REPLAY_BIT);

    return result;
}

VkImageUsageFlags toVkImageUsageFlags(renderer::ImageUsageFlags flags) {
    VkImageUsageFlags result = 0;
    ADD_FLAG_BIT(ImageUsage, IMAGE_USAGE, TRANSFER_SRC_BIT);
    ADD_FLAG_BIT(ImageUsage, IMAGE_USAGE, TRANSFER_DST_BIT);
    ADD_FLAG_BIT(ImageUsage, IMAGE_USAGE, SAMPLED_BIT);
    ADD_FLAG_BIT(ImageUsage, IMAGE_USAGE, STORAGE_BIT);
    ADD_FLAG_BIT(ImageUsage, IMAGE_USAGE, COLOR_ATTACHMENT_BIT);
    ADD_FLAG_BIT(ImageUsage, IMAGE_USAGE, DEPTH_STENCIL_ATTACHMENT_BIT);
    ADD_FLAG_BIT(ImageUsage, IMAGE_USAGE, TRANSIENT_ATTACHMENT_BIT);
    ADD_FLAG_BIT(ImageUsage, IMAGE_USAGE, INPUT_ATTACHMENT_BIT);
    ADD_FLAG_BIT(ImageUsage, IMAGE_USAGE, SHADING_RATE_IMAGE_BIT_NV);
    ADD_FLAG_BIT(ImageUsage, IMAGE_USAGE, FRAGMENT_DENSITY_MAP_BIT_EXT);

    return result;
}

VkImageCreateFlags toVkImageCreateFlags(renderer::ImageCreateFlags flags) {
    VkImageCreateFlags result = 0;
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, SPARSE_BINDING_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, SPARSE_RESIDENCY_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, SPARSE_ALIASED_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, MUTABLE_FORMAT_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, CUBE_COMPATIBLE_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, ALIAS_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, SPLIT_INSTANCE_BIND_REGIONS_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, BLOCK_TEXEL_VIEW_COMPATIBLE_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, EXTENDED_USAGE_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, PROTECTED_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, DISJOINT_BIT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, CORNER_SAMPLED_BIT_NV);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT);
    ADD_FLAG_BIT(ImageCreate, IMAGE_CREATE, SUBSAMPLED_BIT_EXT);
    result |= (flags & static_cast<uint32_t>(renderer::ImageCreateFlagBits::TWO_D_ARRAY_COMPATIBLE_BIT)) ? 
        VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT : 0;

    return result;
}

VkImageTiling toVkImageTiling(renderer::ImageTiling tiling) {
    if (tiling == renderer::ImageTiling::LINEAR) return VK_IMAGE_TILING_LINEAR;
    else if (tiling == renderer::ImageTiling::DRM_FORMAT_MODIFIER_EXT) return VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
    else return VK_IMAGE_TILING_OPTIMAL;
}

VkImageLayout toVkImageLayout(renderer::ImageLayout layout) {
    if (layout == renderer::ImageLayout::GENERAL) return VK_IMAGE_LAYOUT_GENERAL;
    else if (layout == renderer::ImageLayout::COLOR_ATTACHMENT_OPTIMAL) return VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    else if (layout == renderer::ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL) return VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
    else if (layout == renderer::ImageLayout::DEPTH_STENCIL_READ_ONLY_OPTIMAL) return VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL;
    else if (layout == renderer::ImageLayout::SHADER_READ_ONLY_OPTIMAL) return VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    else if (layout == renderer::ImageLayout::TRANSFER_SRC_OPTIMAL) return VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
    else if (layout == renderer::ImageLayout::TRANSFER_DST_OPTIMAL) return VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    else if (layout == renderer::ImageLayout::PREINITIALIZED) return VK_IMAGE_LAYOUT_PREINITIALIZED;
    else if (layout == renderer::ImageLayout::DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL) return VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
    else if (layout == renderer::ImageLayout::DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL) return VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
    else if (layout == renderer::ImageLayout::DEPTH_ATTACHMENT_OPTIMAL) return VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL;
    else if (layout == renderer::ImageLayout::DEPTH_READ_ONLY_OPTIMAL) return VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL;
    else if (layout == renderer::ImageLayout::STENCIL_ATTACHMENT_OPTIMAL) return VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL;
    else if (layout == renderer::ImageLayout::STENCIL_READ_ONLY_OPTIMAL) return VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL;
    else if (layout == renderer::ImageLayout::PRESENT_SRC_KHR) return VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
    else if (layout == renderer::ImageLayout::SHARED_PRESENT_KHR) return VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR;
    else if (layout == renderer::ImageLayout::SHADING_RATE_OPTIMAL_NV) return VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV;
    else if (layout == renderer::ImageLayout::FRAGMENT_DENSITY_MAP_OPTIMAL_EXT) return VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT;
    return VK_IMAGE_LAYOUT_UNDEFINED;
}

VkShaderStageFlagBits toVkShaderStageFlagBits(renderer::ShaderStageFlagBits stage) {
    if (stage == renderer::ShaderStageFlagBits::VERTEX_BIT) return VK_SHADER_STAGE_VERTEX_BIT;
    else if (stage == renderer::ShaderStageFlagBits::TESSELLATION_CONTROL_BIT) return VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT;
    else if (stage == renderer::ShaderStageFlagBits::TESSELLATION_EVALUATION_BIT) return VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT;
    else if (stage == renderer::ShaderStageFlagBits::GEOMETRY_BIT) return VK_SHADER_STAGE_GEOMETRY_BIT;
    else if (stage == renderer::ShaderStageFlagBits::FRAGMENT_BIT) return VK_SHADER_STAGE_FRAGMENT_BIT;
    else if (stage == renderer::ShaderStageFlagBits::COMPUTE_BIT) return VK_SHADER_STAGE_COMPUTE_BIT;
    else if (stage == renderer::ShaderStageFlagBits::ALL_GRAPHICS) return VK_SHADER_STAGE_ALL_GRAPHICS;
    else if (stage == renderer::ShaderStageFlagBits::ALL) return VK_SHADER_STAGE_ALL;
    else if (stage == renderer::ShaderStageFlagBits::RAYGEN_BIT_KHR) return VK_SHADER_STAGE_RAYGEN_BIT_KHR;
    else if (stage == renderer::ShaderStageFlagBits::ANY_HIT_BIT_KHR) return VK_SHADER_STAGE_ANY_HIT_BIT_KHR;
    else if (stage == renderer::ShaderStageFlagBits::CLOSEST_HIT_BIT_KHR) return VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
    else if (stage == renderer::ShaderStageFlagBits::MISS_BIT_KHR) return VK_SHADER_STAGE_MISS_BIT_KHR;
    else if (stage == renderer::ShaderStageFlagBits::INTERSECTION_BIT_KHR) return VK_SHADER_STAGE_INTERSECTION_BIT_KHR;
    else if (stage == renderer::ShaderStageFlagBits::CALLABLE_BIT_KHR) return VK_SHADER_STAGE_CALLABLE_BIT_KHR;
    else if (stage == renderer::ShaderStageFlagBits::TASK_BIT_NV) return VK_SHADER_STAGE_TASK_BIT_NV;
    else if (stage == renderer::ShaderStageFlagBits::MESH_BIT_NV) return VK_SHADER_STAGE_MESH_BIT_NV;
    else if (stage == renderer::ShaderStageFlagBits::MESH_BIT_NV) return VK_SHADER_STAGE_MESH_BIT_NV;
    return VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM;
};

VkMemoryPropertyFlags toVkMemoryPropertyFlags(renderer::MemoryPropertyFlags flags) {
    VkMemoryPropertyFlags result = 0;
    ADD_FLAG_BIT(MemoryProperty, MEMORY_PROPERTY, DEVICE_LOCAL_BIT);
    ADD_FLAG_BIT(MemoryProperty, MEMORY_PROPERTY, HOST_VISIBLE_BIT);
    ADD_FLAG_BIT(MemoryProperty, MEMORY_PROPERTY, HOST_COHERENT_BIT);
    ADD_FLAG_BIT(MemoryProperty, MEMORY_PROPERTY, HOST_CACHED_BIT);
    ADD_FLAG_BIT(MemoryProperty, MEMORY_PROPERTY, LAZILY_ALLOCATED_BIT);
    ADD_FLAG_BIT(MemoryProperty, MEMORY_PROPERTY, PROTECTED_BIT);
    ADD_FLAG_BIT(MemoryProperty, MEMORY_PROPERTY, DEVICE_COHERENT_BIT_AMD);
    ADD_FLAG_BIT(MemoryProperty, MEMORY_PROPERTY, DEVICE_UNCACHED_BIT_AMD);

    return result;
}

VkCommandBufferUsageFlags toCommandBufferUsageFlags(renderer::CommandBufferUsageFlags flags) {
    VkCommandBufferUsageFlags result = 0;
    ADD_FLAG_BIT(CommandBufferUsage, COMMAND_BUFFER_USAGE, ONE_TIME_SUBMIT_BIT);
    ADD_FLAG_BIT(CommandBufferUsage, COMMAND_BUFFER_USAGE, RENDER_PASS_CONTINUE_BIT);
    ADD_FLAG_BIT(CommandBufferUsage, COMMAND_BUFFER_USAGE, SIMULTANEOUS_USE_BIT);

    return result;
}

VkImageType toVkImageType(renderer::ImageType view_type) {
    if (view_type == renderer::ImageType::TYPE_1D) return VK_IMAGE_TYPE_1D;
    else if (view_type == renderer::ImageType::TYPE_2D) return VK_IMAGE_TYPE_2D;
    return VK_IMAGE_TYPE_3D;
}

VkImageViewType toVkImageViewType(renderer::ImageViewType view_type) {
    auto flag = view_type;
    if (view_type == renderer::ImageViewType::VIEW_1D) return VK_IMAGE_VIEW_TYPE_1D;
    else if (view_type == renderer::ImageViewType::VIEW_2D) return VK_IMAGE_VIEW_TYPE_2D;
    else if (view_type == renderer::ImageViewType::VIEW_3D) return VK_IMAGE_VIEW_TYPE_3D;
    else if (view_type == renderer::ImageViewType::VIEW_CUBE) return VK_IMAGE_VIEW_TYPE_CUBE;
    else if (view_type == renderer::ImageViewType::VIEW_1D_ARRAY) return VK_IMAGE_VIEW_TYPE_1D_ARRAY;
    else if (view_type == renderer::ImageViewType::VIEW_2D_ARRAY) return VK_IMAGE_VIEW_TYPE_2D_ARRAY;
    else if (view_type == renderer::ImageViewType::VIEW_CUBE_ARRAY) return VK_IMAGE_VIEW_TYPE_CUBE_ARRAY;
    return VK_IMAGE_VIEW_TYPE_2D;
}

VkImageAspectFlags toVkImageAspectFlags(renderer::ImageAspectFlags flags) {
    VkImageAspectFlags result = 0;
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, COLOR_BIT);
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, DEPTH_BIT);
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, STENCIL_BIT);
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, METADATA_BIT);
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, PLANE_0_BIT);
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, PLANE_1_BIT);
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, PLANE_2_BIT);
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, MEMORY_PLANE_0_BIT_EXT);
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, MEMORY_PLANE_1_BIT_EXT);
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, MEMORY_PLANE_2_BIT_EXT);
    ADD_FLAG_BIT(ImageAspect, IMAGE_ASPECT, MEMORY_PLANE_3_BIT_EXT);
    return result;
}

VkAccessFlags toVkAccessFlags(renderer::AccessFlags flags) {
    VkAccessFlags result = 0;
    ADD_FLAG_BIT(Access, ACCESS, INDIRECT_COMMAND_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, INDEX_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, VERTEX_ATTRIBUTE_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, UNIFORM_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, INPUT_ATTACHMENT_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, SHADER_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, SHADER_WRITE_BIT);
    ADD_FLAG_BIT(Access, ACCESS, COLOR_ATTACHMENT_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, COLOR_ATTACHMENT_WRITE_BIT);
    ADD_FLAG_BIT(Access, ACCESS, DEPTH_STENCIL_ATTACHMENT_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, DEPTH_STENCIL_ATTACHMENT_WRITE_BIT);
    ADD_FLAG_BIT(Access, ACCESS, TRANSFER_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, TRANSFER_WRITE_BIT);
    ADD_FLAG_BIT(Access, ACCESS, HOST_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, HOST_WRITE_BIT);
    ADD_FLAG_BIT(Access, ACCESS, MEMORY_READ_BIT);
    ADD_FLAG_BIT(Access, ACCESS, MEMORY_WRITE_BIT);
    ADD_FLAG_BIT(Access, ACCESS, TRANSFORM_FEEDBACK_WRITE_BIT_EXT);
    ADD_FLAG_BIT(Access, ACCESS, TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT);
    ADD_FLAG_BIT(Access, ACCESS, TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT);
    ADD_FLAG_BIT(Access, ACCESS, CONDITIONAL_RENDERING_READ_BIT_EXT);
    ADD_FLAG_BIT(Access, ACCESS, COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT);
    ADD_FLAG_BIT(Access, ACCESS, ACCELERATION_STRUCTURE_READ_BIT_KHR);
    ADD_FLAG_BIT(Access, ACCESS, ACCELERATION_STRUCTURE_WRITE_BIT_KHR);
    ADD_FLAG_BIT(Access, ACCESS, SHADING_RATE_IMAGE_READ_BIT_NV);
    ADD_FLAG_BIT(Access, ACCESS, FRAGMENT_DENSITY_MAP_READ_BIT_EXT);
    ADD_FLAG_BIT(Access, ACCESS, COMMAND_PREPROCESS_READ_BIT_NV);
    ADD_FLAG_BIT(Access, ACCESS, COMMAND_PREPROCESS_WRITE_BIT_NV);
    return result;
}

VkPipelineStageFlags toVkPipelineStageFlags(renderer::PipelineStageFlags flags) {
    VkPipelineStageFlags result = 0;
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, TOP_OF_PIPE_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, DRAW_INDIRECT_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, VERTEX_INPUT_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, VERTEX_SHADER_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, TESSELLATION_CONTROL_SHADER_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, TESSELLATION_EVALUATION_SHADER_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, GEOMETRY_SHADER_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, FRAGMENT_SHADER_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, EARLY_FRAGMENT_TESTS_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, LATE_FRAGMENT_TESTS_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, COLOR_ATTACHMENT_OUTPUT_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, COMPUTE_SHADER_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, TRANSFER_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, BOTTOM_OF_PIPE_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, HOST_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, ALL_GRAPHICS_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, ALL_COMMANDS_BIT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, TRANSFORM_FEEDBACK_BIT_EXT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, CONDITIONAL_RENDERING_BIT_EXT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, RAY_TRACING_SHADER_BIT_KHR);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, ACCELERATION_STRUCTURE_BUILD_BIT_KHR);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, SHADING_RATE_IMAGE_BIT_NV);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, TASK_SHADER_BIT_NV);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, MESH_SHADER_BIT_NV);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, FRAGMENT_DENSITY_PROCESS_BIT_EXT);
    ADD_FLAG_BIT(PipelineStage, PIPELINE_STAGE, COMMAND_PREPROCESS_BIT_NV);
    return result;
};

VkShaderStageFlags toVkShaderStageFlags(renderer::ShaderStageFlags flags) {
    VkShaderStageFlags result = 0;
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, VERTEX_BIT);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, TESSELLATION_CONTROL_BIT);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, TESSELLATION_EVALUATION_BIT);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, GEOMETRY_BIT);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, FRAGMENT_BIT);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, COMPUTE_BIT);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, RAYGEN_BIT_KHR);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, ANY_HIT_BIT_KHR);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, CLOSEST_HIT_BIT_KHR);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, MISS_BIT_KHR);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, INTERSECTION_BIT_KHR);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, CALLABLE_BIT_KHR);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, TASK_BIT_NV);
    ADD_FLAG_BIT(ShaderStage, SHADER_STAGE, MESH_BIT_NV);

    return result;
}

VkPipelineBindPoint toVkPipelineBindPoint(renderer::PipelineBindPoint bind) {
    if (bind == renderer::PipelineBindPoint::COMPUTE) return VK_PIPELINE_BIND_POINT_COMPUTE;
    else if (bind == renderer::PipelineBindPoint::RAY_TRACING) return VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR;
    return VK_PIPELINE_BIND_POINT_GRAPHICS;
}

VkCommandPoolCreateFlags toVkCommandPoolCreateFlags(renderer::CommandPoolCreateFlags flags) {
    VkCommandPoolCreateFlags result = 0;
    ADD_FLAG_BIT(CommandPoolCreate, COMMAND_POOL_CREATE, TRANSIENT_BIT);
    ADD_FLAG_BIT(CommandPoolCreate, COMMAND_POOL_CREATE, RESET_COMMAND_BUFFER_BIT);
    ADD_FLAG_BIT(CommandPoolCreate, COMMAND_POOL_CREATE, PROTECTED_BIT);
    return result;
}

VkFilter toVkFilter(renderer::Filter filter) {
    if (filter == renderer::Filter::NEAREST) return VK_FILTER_NEAREST;
    else if (filter == renderer::Filter::CUBIC_IMG) return VK_FILTER_CUBIC_IMG;
    return VK_FILTER_LINEAR;
}

VkDescriptorType toVkDescriptorType(renderer::DescriptorType type) {
    if (type == renderer::DescriptorType::SAMPLER) return VK_DESCRIPTOR_TYPE_SAMPLER;
    else if (type == renderer::DescriptorType::COMBINED_IMAGE_SAMPLER) return VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    else if (type == renderer::DescriptorType::SAMPLED_IMAGE) return VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
    else if (type == renderer::DescriptorType::STORAGE_IMAGE) return VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
    else if (type == renderer::DescriptorType::UNIFORM_TEXEL_BUFFER) return VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER;
    else if (type == renderer::DescriptorType::STORAGE_TEXEL_BUFFER) return VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
    else if (type == renderer::DescriptorType::UNIFORM_BUFFER) return VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    else if (type == renderer::DescriptorType::STORAGE_BUFFER) return VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
    else if (type == renderer::DescriptorType::UNIFORM_BUFFER_DYNAMIC) return VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC;
    else if (type == renderer::DescriptorType::STORAGE_BUFFER_DYNAMIC) return VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC;
    else if (type == renderer::DescriptorType::INPUT_ATTACHMENT) return VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;
    else if (type == renderer::DescriptorType::INLINE_UNIFORM_BLOCK_EXT) return VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT;
    else if (type == renderer::DescriptorType::ACCELERATION_STRUCTURE_KHR) return VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;
    return VK_DESCRIPTOR_TYPE_SAMPLER;
}

VkSamplerAddressMode toVkSamplerAddressMode(renderer::SamplerAddressMode mode) {
    if (mode == renderer::SamplerAddressMode::MIRRORED_REPEAT) return VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT;
    else if (mode == renderer::SamplerAddressMode::CLAMP_TO_EDGE) return VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    else if (mode == renderer::SamplerAddressMode::CLAMP_TO_BORDER) return VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
    else if (mode == renderer::SamplerAddressMode::MIRROR_CLAMP_TO_EDGE) return VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
    return VK_SAMPLER_ADDRESS_MODE_REPEAT;
}

VkSamplerMipmapMode toVkSamplerMipmapMode(renderer::SamplerMipmapMode mode) {
    if (mode == renderer::SamplerMipmapMode::NEAREST) return VK_SAMPLER_MIPMAP_MODE_NEAREST;
    return VK_SAMPLER_MIPMAP_MODE_LINEAR;
}

VkColorSpaceKHR toVkColorSpace(renderer::ColorSpace color_space) {
    if (color_space == renderer::ColorSpace::DISPLAY_P3_NONLINEAR_EXT) return VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT;
    else if (color_space == renderer::ColorSpace::DISPLAY_P3_LINEAR_EXT) return VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT;
    else if (color_space == renderer::ColorSpace::DCI_P3_NONLINEAR_EXT) return VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT;
    else if (color_space == renderer::ColorSpace::BT709_LINEAR_EXT) return VK_COLOR_SPACE_BT709_LINEAR_EXT;
    else if (color_space == renderer::ColorSpace::BT709_NONLINEAR_EXT) return VK_COLOR_SPACE_BT709_NONLINEAR_EXT;
    else if (color_space == renderer::ColorSpace::BT2020_LINEAR_EXT) return VK_COLOR_SPACE_BT2020_LINEAR_EXT;
    else if (color_space == renderer::ColorSpace::HDR10_ST2084_EXT) return VK_COLOR_SPACE_HDR10_ST2084_EXT;
    else if (color_space == renderer::ColorSpace::DOLBYVISION_EXT) return VK_COLOR_SPACE_DOLBYVISION_EXT;
    else if (color_space == renderer::ColorSpace::HDR10_HLG_EXT) return VK_COLOR_SPACE_HDR10_HLG_EXT;
    else if (color_space == renderer::ColorSpace::ADOBERGB_LINEAR_EXT) return VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT;
    else if (color_space == renderer::ColorSpace::ADOBERGB_NONLINEAR_EXT) return VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT;
    else if (color_space == renderer::ColorSpace::PASS_THROUGH_EXT) return VK_COLOR_SPACE_PASS_THROUGH_EXT;
    else if (color_space == renderer::ColorSpace::EXTENDED_SRGB_NONLINEAR_EXT) return VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT;
    else if (color_space == renderer::ColorSpace::DISPLAY_NATIVE_AMD) return VK_COLOR_SPACE_DISPLAY_NATIVE_AMD;
    return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
}

renderer::ColorSpace fromVkColorSpace(VkColorSpaceKHR color_space) {
    if (color_space == VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT) return renderer::ColorSpace::DISPLAY_P3_NONLINEAR_EXT;
    else if (color_space == VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT) return renderer::ColorSpace::DISPLAY_P3_LINEAR_EXT;
    else if (color_space == VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT) return renderer::ColorSpace::DCI_P3_NONLINEAR_EXT;
    else if (color_space == VK_COLOR_SPACE_BT709_LINEAR_EXT) return renderer::ColorSpace::BT709_LINEAR_EXT;
    else if (color_space == VK_COLOR_SPACE_BT709_NONLINEAR_EXT) return renderer::ColorSpace::BT709_NONLINEAR_EXT;
    else if (color_space == VK_COLOR_SPACE_BT2020_LINEAR_EXT) return renderer::ColorSpace::BT2020_LINEAR_EXT;
    else if (color_space == VK_COLOR_SPACE_HDR10_ST2084_EXT) return renderer::ColorSpace::HDR10_ST2084_EXT;
    else if (color_space == VK_COLOR_SPACE_DOLBYVISION_EXT) return renderer::ColorSpace::DOLBYVISION_EXT;
    else if (color_space == VK_COLOR_SPACE_HDR10_HLG_EXT) return renderer::ColorSpace::HDR10_HLG_EXT;
    else if (color_space == VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT) return renderer::ColorSpace::ADOBERGB_LINEAR_EXT;
    else if (color_space == VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT) return renderer::ColorSpace::ADOBERGB_NONLINEAR_EXT;
    else if (color_space == VK_COLOR_SPACE_PASS_THROUGH_EXT) return renderer::ColorSpace::PASS_THROUGH_EXT;
    else if (color_space == VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT) return renderer::ColorSpace::EXTENDED_SRGB_NONLINEAR_EXT;
    else if (color_space == VK_COLOR_SPACE_DISPLAY_NATIVE_AMD) return renderer::ColorSpace::DISPLAY_NATIVE_AMD;
    return renderer::ColorSpace::SRGB_NONLINEAR_KHR;
}

VkPresentModeKHR toVkPresentMode(renderer::PresentMode mode) {
    if (mode == renderer::PresentMode::MAILBOX_KHR) return VK_PRESENT_MODE_MAILBOX_KHR;
    else if (mode == renderer::PresentMode::FIFO_KHR) return VK_PRESENT_MODE_FIFO_KHR;
    else if (mode == renderer::PresentMode::FIFO_RELAXED_KHR) return VK_PRESENT_MODE_FIFO_RELAXED_KHR;
    else if (mode == renderer::PresentMode::SHARED_DEMAND_REFRESH_KHR) return VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR;
    else if (mode == renderer::PresentMode::SHARED_CONTINUOUS_REFRESH_KHR) return VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR;
    return VK_PRESENT_MODE_IMMEDIATE_KHR;
}

VkSurfaceTransformFlagBitsKHR toVkSurfaceTransformFlags(renderer::SurfaceTransformFlagBits flag) {
    if (flag == renderer::SurfaceTransformFlagBits::ROTATE_90_BIT_KHR) return VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR;
    else if (flag == renderer::SurfaceTransformFlagBits::ROTATE_180_BIT_KHR) return VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR;
    else if (flag == renderer::SurfaceTransformFlagBits::ROTATE_270_BIT_KHR) return VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR;
    else if (flag == renderer::SurfaceTransformFlagBits::HORIZONTAL_MIRROR_BIT_KHR) return VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR;
    else if (flag == renderer::SurfaceTransformFlagBits::HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR) return VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR;
    else if (flag == renderer::SurfaceTransformFlagBits::HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR) return VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR;
    else if (flag == renderer::SurfaceTransformFlagBits::HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR) return VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR;
    else if (flag == renderer::SurfaceTransformFlagBits::INHERIT_BIT_KHR) return VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR;
    return VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
}

renderer::SurfaceTransformFlagBits fromVkSurfaceTransformFlags(VkSurfaceTransformFlagBitsKHR flag) {
    if (flag == VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR) return renderer::SurfaceTransformFlagBits::ROTATE_90_BIT_KHR;
    else if (flag == VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR) return renderer::SurfaceTransformFlagBits::ROTATE_180_BIT_KHR;
    else if (flag == VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR) return renderer::SurfaceTransformFlagBits::ROTATE_270_BIT_KHR;
    else if (flag == VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR) return renderer::SurfaceTransformFlagBits::HORIZONTAL_MIRROR_BIT_KHR;
    else if (flag == VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR) return renderer::SurfaceTransformFlagBits::HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR;
    else if (flag == VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR) return renderer::SurfaceTransformFlagBits::HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR;
    else if (flag == VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR) return renderer::SurfaceTransformFlagBits::HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR;
    else if (flag == VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR) return renderer::SurfaceTransformFlagBits::INHERIT_BIT_KHR;
    return renderer::SurfaceTransformFlagBits::IDENTITY_BIT_KHR;
}

VkColorComponentFlags toVkColorComponentFlags(renderer::ColorComponentFlags flags) {
    VkColorComponentFlags result = 0;
    ADD_FLAG_BIT(ColorComponent, COLOR_COMPONENT, R_BIT);
    ADD_FLAG_BIT(ColorComponent, COLOR_COMPONENT, G_BIT);
    ADD_FLAG_BIT(ColorComponent, COLOR_COMPONENT, B_BIT);
    ADD_FLAG_BIT(ColorComponent, COLOR_COMPONENT, A_BIT);
    return result;
}

VkPrimitiveTopology toVkPrimitiveTopology(renderer::PrimitiveTopology primitive) {
    auto flag = primitive;
    SELECT_FLAG(PrimitiveTopology, PRIMITIVE_TOPOLOGY, LINE_LIST);
    else SELECT_FLAG(PrimitiveTopology, PRIMITIVE_TOPOLOGY, LINE_STRIP);
    else SELECT_FLAG(PrimitiveTopology, PRIMITIVE_TOPOLOGY, TRIANGLE_LIST);
    else SELECT_FLAG(PrimitiveTopology, PRIMITIVE_TOPOLOGY, TRIANGLE_STRIP);
    else SELECT_FLAG(PrimitiveTopology, PRIMITIVE_TOPOLOGY, TRIANGLE_FAN);
    else SELECT_FLAG(PrimitiveTopology, PRIMITIVE_TOPOLOGY, LINE_LIST_WITH_ADJACENCY);
    else SELECT_FLAG(PrimitiveTopology, PRIMITIVE_TOPOLOGY, LINE_STRIP_WITH_ADJACENCY);
    else SELECT_FLAG(PrimitiveTopology, PRIMITIVE_TOPOLOGY, TRIANGLE_LIST_WITH_ADJACENCY);
    else SELECT_FLAG(PrimitiveTopology, PRIMITIVE_TOPOLOGY, TRIANGLE_STRIP_WITH_ADJACENCY);
    else SELECT_FLAG(PrimitiveTopology, PRIMITIVE_TOPOLOGY, PATCH_LIST);
    return VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
}

VkBlendFactor toVkBlendFactor(renderer::BlendFactor blend_factor) {
    auto flag = blend_factor;
    SELECT_FLAG(BlendFactor, BLEND_FACTOR, ZERO);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, ONE);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, SRC_COLOR);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, ONE_MINUS_SRC_COLOR);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, DST_COLOR);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, ONE_MINUS_DST_COLOR);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, SRC_ALPHA);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, ONE_MINUS_SRC_ALPHA);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, DST_ALPHA);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, ONE_MINUS_DST_ALPHA);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, CONSTANT_COLOR);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, ONE_MINUS_CONSTANT_COLOR);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, CONSTANT_ALPHA);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, ONE_MINUS_CONSTANT_ALPHA);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, SRC_ALPHA_SATURATE);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, SRC1_COLOR);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, ONE_MINUS_SRC1_COLOR);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, SRC1_ALPHA);
    else SELECT_FLAG(BlendFactor, BLEND_FACTOR, ONE_MINUS_SRC1_ALPHA);
    return VK_BLEND_FACTOR_ZERO;
}

VkBlendOp toVkBlendOp(renderer::BlendOp blend_op) {
    auto flag = blend_op;
    SELECT_FLAG(BlendOp, BLEND_OP, ADD);
    else SELECT_FLAG(BlendOp, BLEND_OP, SUBTRACT);
    else SELECT_FLAG(BlendOp, BLEND_OP, REVERSE_SUBTRACT);
    else SELECT_FLAG(BlendOp, BLEND_OP, MIN);
    else SELECT_FLAG(BlendOp, BLEND_OP, MAX);
    else SELECT_FLAG(BlendOp, BLEND_OP, ZERO_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, SRC_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, DST_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, SRC_OVER_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, DST_OVER_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, SRC_IN_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, DST_IN_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, SRC_OUT_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, DST_OUT_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, SRC_ATOP_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, DST_ATOP_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, XOR_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, MULTIPLY_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, SCREEN_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, OVERLAY_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, DARKEN_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, LIGHTEN_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, COLORDODGE_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, COLORBURN_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, HARDLIGHT_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, SOFTLIGHT_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, DIFFERENCE_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, EXCLUSION_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, INVERT_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, INVERT_RGB_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, LINEARDODGE_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, LINEARBURN_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, VIVIDLIGHT_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, LINEARLIGHT_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, PINLIGHT_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, HARDMIX_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, HSL_HUE_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, HSL_SATURATION_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, HSL_COLOR_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, HSL_LUMINOSITY_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, PLUS_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, PLUS_CLAMPED_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, PLUS_CLAMPED_ALPHA_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, PLUS_DARKER_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, MINUS_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, MINUS_CLAMPED_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, CONTRAST_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, INVERT_OVG_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, RED_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, GREEN_EXT);
    else SELECT_FLAG(BlendOp, BLEND_OP, BLUE_EXT);
    return VK_BLEND_OP_ADD;
};

VkIndexType toVkIndexType(renderer::IndexType index_type) {
    auto flag = index_type;
    SELECT_FLAG(IndexType, INDEX_TYPE, UINT32);
    else SELECT_FLAG(IndexType, INDEX_TYPE, NONE_KHR);
    else SELECT_FLAG(IndexType, INDEX_TYPE, UINT8_EXT);
    return VK_INDEX_TYPE_UINT16;
}

VkVertexInputRate toVkVertexInputRate(renderer::VertexInputRate input_rate) {
    auto flag = input_rate;
    SELECT_FLAG(VertexInputRate, VERTEX_INPUT_RATE, INSTANCE);
    return VK_VERTEX_INPUT_RATE_VERTEX;
}

VkLogicOp toVkLogicOp(renderer::LogicOp logic_op) {
    auto flag = logic_op;
    SELECT_FLAG(LogicOp, LOGIC_OP, CLEAR);
    else SELECT_FLAG(LogicOp, LOGIC_OP, AND);
    else SELECT_FLAG(LogicOp, LOGIC_OP, AND_REVERSE);
    else SELECT_FLAG(LogicOp, LOGIC_OP, COPY);
    else SELECT_FLAG(LogicOp, LOGIC_OP, AND_INVERTED);
    else SELECT_FLAG(LogicOp, LOGIC_OP, NO_OP);
    else SELECT_FLAG(LogicOp, LOGIC_OP, XOR);
    else SELECT_FLAG(LogicOp, LOGIC_OP, OR);
    else SELECT_FLAG(LogicOp, LOGIC_OP, NOR);
    else SELECT_FLAG(LogicOp, LOGIC_OP, EQUIVALENT);
    else SELECT_FLAG(LogicOp, LOGIC_OP, INVERT);
    else SELECT_FLAG(LogicOp, LOGIC_OP, OR_REVERSE);
    else SELECT_FLAG(LogicOp, LOGIC_OP, COPY_INVERTED);
    else SELECT_FLAG(LogicOp, LOGIC_OP, OR_INVERTED);
    else SELECT_FLAG(LogicOp, LOGIC_OP, NAND);
    else SELECT_FLAG(LogicOp, LOGIC_OP, SET);
    return VK_LOGIC_OP_NO_OP;
}

VkPolygonMode toVkPolygonMode(renderer::PolygonMode polygon_mode) {
    auto flag = polygon_mode;
    SELECT_FLAG(PolygonMode, POLYGON_MODE, FILL);
    else SELECT_FLAG(PolygonMode, POLYGON_MODE, LINE);
    else SELECT_FLAG(PolygonMode, POLYGON_MODE, POINT);
    else SELECT_FLAG(PolygonMode, POLYGON_MODE, FILL_RECTANGLE_NV);
    return VK_POLYGON_MODE_FILL;
};

VkCullModeFlags toVkCullModeFlags(renderer::CullModeFlags flags) {
    VkCullModeFlags result = 0;
    ADD_FLAG_BIT(CullMode, CULL_MODE, NONE);
    ADD_FLAG_BIT(CullMode, CULL_MODE, FRONT_BIT);
    ADD_FLAG_BIT(CullMode, CULL_MODE, BACK_BIT);
    return result;
}

VkFrontFace toVkFrontFace(renderer::FrontFace front_face) {
    auto flag = front_face;
    SELECT_FLAG(FrontFace, FRONT_FACE, COUNTER_CLOCKWISE);
    SELECT_FLAG(FrontFace, FRONT_FACE, CLOCKWISE);
    return VK_FRONT_FACE_CLOCKWISE;
}

VkSampleCountFlags toVkSampleCountFlags(renderer::SampleCountFlags flags) {
    VkSampleCountFlags result = 0;
    result |= (flags & static_cast<uint32_t>(renderer::SampleCountFlagBits::SC_1_BIT)) ? VK_SAMPLE_COUNT_1_BIT : 0;
    result |= (flags & static_cast<uint32_t>(renderer::SampleCountFlagBits::SC_2_BIT)) ? VK_SAMPLE_COUNT_2_BIT : 0;
    result |= (flags & static_cast<uint32_t>(renderer::SampleCountFlagBits::SC_4_BIT)) ? VK_SAMPLE_COUNT_4_BIT : 0;
    result |= (flags & static_cast<uint32_t>(renderer::SampleCountFlagBits::SC_8_BIT)) ? VK_SAMPLE_COUNT_8_BIT : 0;
    result |= (flags & static_cast<uint32_t>(renderer::SampleCountFlagBits::SC_16_BIT)) ? VK_SAMPLE_COUNT_16_BIT : 0;
    result |= (flags & static_cast<uint32_t>(renderer::SampleCountFlagBits::SC_32_BIT)) ? VK_SAMPLE_COUNT_32_BIT : 0;
    result |= (flags & static_cast<uint32_t>(renderer::SampleCountFlagBits::SC_64_BIT)) ? VK_SAMPLE_COUNT_64_BIT : 0;
    return result;
}

VkCompareOp toVkCompareOp(renderer::CompareOp compare_op) {
    auto flag = compare_op;
    SELECT_FLAG(CompareOp, COMPARE_OP, NEVER);
    else SELECT_FLAG(CompareOp, COMPARE_OP, LESS);
    else SELECT_FLAG(CompareOp, COMPARE_OP, EQUAL);
    else SELECT_FLAG(CompareOp, COMPARE_OP, LESS_OR_EQUAL);
    else SELECT_FLAG(CompareOp, COMPARE_OP, GREATER);
    else SELECT_FLAG(CompareOp, COMPARE_OP, NOT_EQUAL);
    else SELECT_FLAG(CompareOp, COMPARE_OP, GREATER_OR_EQUAL);
    else SELECT_FLAG(CompareOp, COMPARE_OP, ALWAYS);
    return VK_COMPARE_OP_LESS;
}

VkStencilOp toVkStencilOp(renderer::StencilOp stencil_op) {
    auto flag = stencil_op;
    SELECT_FLAG(StencilOp, STENCIL_OP, KEEP);
    else SELECT_FLAG(StencilOp, STENCIL_OP, ZERO);
    else SELECT_FLAG(StencilOp, STENCIL_OP, REPLACE);
    else SELECT_FLAG(StencilOp, STENCIL_OP, INCREMENT_AND_CLAMP);
    else SELECT_FLAG(StencilOp, STENCIL_OP, DECREMENT_AND_CLAMP);
    else SELECT_FLAG(StencilOp, STENCIL_OP, INVERT);
    else SELECT_FLAG(StencilOp, STENCIL_OP, INCREMENT_AND_WRAP);
    else SELECT_FLAG(StencilOp, STENCIL_OP, DECREMENT_AND_WRAP);
    return VK_STENCIL_OP_KEEP;
}

VkAttachmentLoadOp toVkAttachmentLoadOp(
    const renderer::AttachmentLoadOp load_op) {
    auto flag = load_op;
    SELECT_FLAG(AttachmentLoadOp, ATTACHMENT_LOAD_OP, LOAD);
    else SELECT_FLAG(AttachmentLoadOp, ATTACHMENT_LOAD_OP, CLEAR);
    else SELECT_FLAG(AttachmentLoadOp, ATTACHMENT_LOAD_OP, DONT_CARE);
    return VK_ATTACHMENT_LOAD_OP_DONT_CARE;
};

VkAttachmentStoreOp toVkAttachmentStoreOp(
    const renderer::AttachmentStoreOp store_op) {
    auto flag = store_op;
    SELECT_FLAG(AttachmentStoreOp, ATTACHMENT_STORE_OP, STORE);
    else SELECT_FLAG(AttachmentStoreOp, ATTACHMENT_STORE_OP, DONT_CARE);
    else SELECT_FLAG(AttachmentStoreOp, ATTACHMENT_STORE_OP, NONE_QCOM);
    return VK_ATTACHMENT_STORE_OP_DONT_CARE;
}

VkGeometryTypeKHR toVkGeometryType(
    const renderer::GeometryType& geometry_type) {
    auto flag = geometry_type;
    SELECT_FLAG(GeometryType, GEOMETRY_TYPE, TRIANGLES_KHR);
    else SELECT_FLAG(GeometryType, GEOMETRY_TYPE, AABBS_KHR);
    else SELECT_FLAG(GeometryType, GEOMETRY_TYPE, INSTANCES_KHR);
    return VK_GEOMETRY_TYPE_TRIANGLES_KHR;
}

VkGeometryInstanceFlagsKHR toVkGeometryInstanceFlags(
    const renderer::GeometryInstanceFlags& flags) {
    VkGeometryInstanceFlagsKHR result = 0;
    ADD_FLAG_BIT(GeometryInstance, GEOMETRY_INSTANCE, TRIANGLE_FACING_CULL_DISABLE_BIT_KHR);
    ADD_FLAG_BIT(GeometryInstance, GEOMETRY_INSTANCE, TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR);
    ADD_FLAG_BIT(GeometryInstance, GEOMETRY_INSTANCE, FORCE_OPAQUE_BIT_KHR);
    ADD_FLAG_BIT(GeometryInstance, GEOMETRY_INSTANCE, FORCE_NO_OPAQUE_BIT_KHR);
    return result;
}

VkAccelerationStructureGeometryKHR
toVkAsGeometry(
    const renderer::AccelerationStructureGeometry& as_geo) {
    VkAccelerationStructureGeometryKHR vk_as_geo;

    const auto& geo_type = as_geo.geometry_type;
    vk_as_geo.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;
    vk_as_geo.pNext = nullptr;
    vk_as_geo.geometryType = helper::toVkGeometryType(as_geo.geometry_type);
    vk_as_geo.flags = helper::toVkGeometryFlags(as_geo.flags);

    if (geo_type == renderer::GeometryType::TRIANGLES_KHR) {
        auto& triangles = vk_as_geo.geometry.triangles;
        const auto& src_triangles = as_geo.geometry.triangles;
        triangles.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;// ACCELERATION_STRUCTURE_GEOMETRY_KHR;
        triangles.pNext = nullptr;
        triangles.vertexFormat = helper::toVkFormat(src_triangles.vertex_format);
        triangles.vertexData.hostAddress = src_triangles.vertex_data.host_address;
        triangles.vertexStride = src_triangles.vertex_stride;
        triangles.maxVertex = src_triangles.max_vertex;
        triangles.indexType = helper::toVkIndexType(src_triangles.index_type);
        triangles.indexData.hostAddress = src_triangles.index_data.host_address;
        triangles.transformData.hostAddress = src_triangles.transform_data.host_address; 
    }
    else if (geo_type == renderer::GeometryType::AABBS_KHR) {
        auto& aabbs = vk_as_geo.geometry.aabbs;
        const auto& src_aabbs = as_geo.geometry.aabbs;
        aabbs.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR;
        aabbs.pNext = nullptr;
        aabbs.stride = src_aabbs.stride;
        aabbs.data.hostAddress = src_aabbs.data.host_address;
    }
    else if (geo_type == renderer::GeometryType::INSTANCES_KHR) {
        auto& instances = vk_as_geo.geometry.instances;
        const auto& src_instances = as_geo.geometry.instances;
        instances.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR;
        instances.pNext = nullptr;
        instances.data.hostAddress = src_instances.data.host_address;
        instances.arrayOfPointers = src_instances.array_of_pointers;
    }

    return vk_as_geo;
}

VkAccelerationStructureBuildGeometryInfoKHR
toVkAccelerationStructureBuildGeometryInfo(
    const AccelerationStructureBuildGeometryInfo& build_info,
    std::unique_ptr<VkAccelerationStructureGeometryKHR[]>& geometries) {
    const auto geom_count = build_info.geometries.size();
    geometries = std::make_unique<VkAccelerationStructureGeometryKHR[]>(geom_count);
    for (auto i = 0; i < geom_count; i++) {
        geometries[i] = helper::toVkAsGeometry(*build_info.geometries[i]);
    }

    VkAccelerationStructureBuildGeometryInfoKHR as_build_geo_info{};
    as_build_geo_info.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;
    as_build_geo_info.type = helper::toVkAccelerationStructureType(build_info.type);
    as_build_geo_info.flags = helper::toVkBuildAccelerationStructureFlags(build_info.flags);
    as_build_geo_info.mode = helper::toVkBuildAccelerationStructureMode(build_info.mode);
    as_build_geo_info.dstAccelerationStructure = reinterpret_cast<VkAccelerationStructureKHR>(build_info.dst_as);
    as_build_geo_info.srcAccelerationStructure = reinterpret_cast<VkAccelerationStructureKHR>(build_info.src_as);
    as_build_geo_info.scratchData.hostAddress = build_info.scratch_data.host_address;
    as_build_geo_info.geometryCount = static_cast<uint32_t>(geom_count);
    as_build_geo_info.pGeometries = &geometries[0];

    return as_build_geo_info;
}

VkAccelerationStructureBuildRangeInfoKHR
toVkAccelerationStructureBuildRangeInfo(
    const AccelerationStructureBuildRangeInfo& as_build_range_info) {
    VkAccelerationStructureBuildRangeInfoKHR vk_as_build_range_info{};
    vk_as_build_range_info.firstVertex = as_build_range_info.first_vertex;
    vk_as_build_range_info.primitiveCount = as_build_range_info.primitive_count;
    vk_as_build_range_info.primitiveOffset = as_build_range_info.primitive_offset;
    vk_as_build_range_info.transformOffset = as_build_range_info.transform_offset;

    return vk_as_build_range_info;
}

VkAttachmentDescriptionFlags toVkAttachmentDescriptionFlags(renderer::AttachmentDescriptionFlags flags) {
    VkAttachmentDescriptionFlags result = 0;
    ADD_FLAG_BIT(AttachmentDescription, ATTACHMENT_DESCRIPTION, MAY_ALIAS_BIT);
    return result;
}

VkDependencyFlags toVkDependencyFlags(renderer::DependencyFlags flags) {
    VkDependencyFlags result = 0;
    ADD_FLAG_BIT(Dependency, DEPENDENCY, BY_REGION_BIT);
    ADD_FLAG_BIT(Dependency, DEPENDENCY, DEVICE_GROUP_BIT);
    ADD_FLAG_BIT(Dependency, DEPENDENCY, VIEW_LOCAL_BIT);
    return result;
}

VkGeometryFlagsKHR toVkGeometryFlags(const renderer::GeometryFlags& flags) {
    VkGeometryFlagsKHR result = 0;
    ADD_FLAG_BIT(Geometry, GEOMETRY, OPAQUE_BIT_KHR);
    ADD_FLAG_BIT(Geometry, GEOMETRY, NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR);
    return result;
}

VkAccelerationStructureTypeKHR
toVkAccelerationStructureType(
    const renderer::AccelerationStructureType& as_type) {
    auto flag = as_type;
    SELECT_FLAG(AccelerationStructureType, ACCELERATION_STRUCTURE_TYPE, TOP_LEVEL_KHR);
    else SELECT_FLAG(AccelerationStructureType, ACCELERATION_STRUCTURE_TYPE, BOTTOM_LEVEL_KHR);
    else SELECT_FLAG(AccelerationStructureType, ACCELERATION_STRUCTURE_TYPE, GENERIC_KHR);
    return VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
}

VkBuildAccelerationStructureFlagsKHR
toVkBuildAccelerationStructureFlags(
    const renderer::BuildAccelerationStructureFlags& flags) {
    VkBuildAccelerationStructureFlagsKHR result = 0;
    ADD_FLAG_BIT(BuildAccelerationStructure, BUILD_ACCELERATION_STRUCTURE, ALLOW_UPDATE_BIT_KHR);
    ADD_FLAG_BIT(BuildAccelerationStructure, BUILD_ACCELERATION_STRUCTURE, ALLOW_COMPACTION_BIT_KHR);
    ADD_FLAG_BIT(BuildAccelerationStructure, BUILD_ACCELERATION_STRUCTURE, PREFER_FAST_TRACE_BIT_KHR);
    ADD_FLAG_BIT(BuildAccelerationStructure, BUILD_ACCELERATION_STRUCTURE, PREFER_FAST_BUILD_BIT_KHR);
    ADD_FLAG_BIT(BuildAccelerationStructure, BUILD_ACCELERATION_STRUCTURE, LOW_MEMORY_BIT_KHR);
    return result;
}

VkBuildAccelerationStructureModeKHR
toVkBuildAccelerationStructureMode(
    const renderer::BuildAccelerationStructureMode& as_mode) {
    auto flag = as_mode;
    SELECT_FLAG(BuildAccelerationStructureMode, BUILD_ACCELERATION_STRUCTURE_MODE, BUILD_KHR);
    else SELECT_FLAG(BuildAccelerationStructureMode, BUILD_ACCELERATION_STRUCTURE_MODE, UPDATE_KHR);
    return VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;
}

VkAccelerationStructureBuildTypeKHR
toVkAccelerationStructureBuildType(
    const renderer::AccelerationStructureBuildType& as_build_type) {
    auto flag = as_build_type;
    SELECT_FLAG(AccelerationStructureBuildType, ACCELERATION_STRUCTURE_BUILD_TYPE, HOST_KHR);
    else SELECT_FLAG(AccelerationStructureBuildType, ACCELERATION_STRUCTURE_BUILD_TYPE, DEVICE_KHR);
    else SELECT_FLAG(AccelerationStructureBuildType, ACCELERATION_STRUCTURE_BUILD_TYPE, HOST_OR_DEVICE_KHR);
    return VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR;
}

VkSubpassDescriptionFlags toVkSubpassDescriptionFlags(renderer::SubpassDescriptionFlags flags) {
    VkSubpassDescriptionFlags result = 0;
    ADD_FLAG_BIT(SubpassDescription, SUBPASS_DESCRIPTION, PER_VIEW_ATTRIBUTES_BIT_NVX);
    ADD_FLAG_BIT(SubpassDescription, SUBPASS_DESCRIPTION, PER_VIEW_POSITION_X_ONLY_BIT_NVX);
    ADD_FLAG_BIT(SubpassDescription, SUBPASS_DESCRIPTION, FRAGMENT_REGION_BIT_QCOM);
    ADD_FLAG_BIT(SubpassDescription, SUBPASS_DESCRIPTION, SHADER_RESOLVE_BIT_QCOM);
    return result;
}

VkRayTracingShaderGroupTypeKHR
toVkRayTracingShaderGroupType(
    const renderer::RayTracingShaderGroupType& rt_shader_group_type) {
    auto flag = rt_shader_group_type;
    SELECT_FLAG(RayTracingShaderGroupType, RAY_TRACING_SHADER_GROUP_TYPE, GENERAL_KHR);
    else SELECT_FLAG(RayTracingShaderGroupType, RAY_TRACING_SHADER_GROUP_TYPE, TRIANGLES_HIT_GROUP_KHR);
    else SELECT_FLAG(RayTracingShaderGroupType, RAY_TRACING_SHADER_GROUP_TYPE, PROCEDURAL_HIT_GROUP_KHR);
    return VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;
}

VkStridedDeviceAddressRegionKHR
toVkStridedDeviceAddressRegion(
    const renderer::StridedDeviceAddressRegion& device_address_region) {
    VkStridedDeviceAddressRegionKHR result;
    result.deviceAddress = device_address_region.device_address;
    result.size = device_address_region.size;
    result.stride = device_address_region.stride;

    return result;
}

std::vector<VkVertexInputBindingDescription> toVkVertexInputBindingDescription(
    const std::vector<renderer::VertexInputBindingDescription>& description) {
    std::vector<VkVertexInputBindingDescription> binding_description(description.size());
    for (int i = 0; i < description.size(); i++) {
        binding_description[i].binding = description[i].binding;
        binding_description[i].stride = description[i].stride;
        binding_description[i].inputRate = toVkVertexInputRate(description[i].input_rate);
    }
    return binding_description;
}

std::vector<VkVertexInputAttributeDescription> toVkVertexInputAttributeDescription(
    const std::vector<renderer::VertexInputAttributeDescription>& description) {
    std::vector<VkVertexInputAttributeDescription> result(description.size());
    for (int i = 0; i < description.size(); i++) {
        result[i].binding = description[i].binding;
        result[i].location = description[i].location;
        result[i].offset = static_cast<uint32_t>(description[i].offset);
        result[i].format = toVkFormat(description[i].format);
    }

    return result;
}

VkImageSubresourceLayers toVkImageSubresourceLayers(
    const ImageSubresourceLayers& layers)
{
    VkImageSubresourceLayers vk_layers;
    vk_layers.aspectMask = helper::toVkImageAspectFlags(layers.aspect_mask);
    vk_layers.mipLevel = layers.mip_level;
    vk_layers.baseArrayLayer = layers.base_array_layer;
    vk_layers.layerCount = layers.layer_count;
    return vk_layers;
}

VkBufferCopy toVkBufferCopy(const BufferCopyInfo& copy_info) {
    VkBufferCopy vk_copy_info;
    vk_copy_info.srcOffset = copy_info.src_offset;
    vk_copy_info.dstOffset = copy_info.dst_offset;
    vk_copy_info.size = copy_info.size;
    return vk_copy_info;
}

VkImageCopy toVkImageCopy(const ImageCopyInfo& copy_info) {
    VkImageCopy vk_copy_info;
    vk_copy_info.srcSubresource = toVkImageSubresourceLayers(copy_info.src_subresource);
    vk_copy_info.srcOffset = toVkOffset3D(copy_info.src_offset);
    vk_copy_info.dstSubresource = toVkImageSubresourceLayers(copy_info.dst_subresource);
    vk_copy_info.dstOffset = toVkOffset3D(copy_info.dst_offset);
    vk_copy_info.extent = toVkExtent3D(copy_info.extent);
    return vk_copy_info;
}
 
VkImageBlit toVkImageBlit(const ImageBlitInfo& blit_info) {
    VkImageBlit vk_blit_info;
    vk_blit_info.srcSubresource = toVkImageSubresourceLayers(blit_info.src_subresource);
    vk_blit_info.srcOffsets[0] = toVkOffset3D(blit_info.src_offsets[0]);
    vk_blit_info.srcOffsets[1] = toVkOffset3D(blit_info.src_offsets[1]);
    vk_blit_info.dstSubresource = toVkImageSubresourceLayers(blit_info.dst_subresource);
    vk_blit_info.dstOffsets[0] = toVkOffset3D(blit_info.dst_offsets[0]);
    vk_blit_info.dstOffsets[1] = toVkOffset3D(blit_info.dst_offsets[1]);
    return vk_blit_info;
}

VkImageResolve toVkImageResolve(const ImageResolveInfo& resolve_info) {
    VkImageResolve vk_resolve_info;
    vk_resolve_info.srcSubresource = toVkImageSubresourceLayers(resolve_info.src_subresource);
    vk_resolve_info.srcOffset = toVkOffset3D(resolve_info.src_offset);
    vk_resolve_info.dstSubresource = toVkImageSubresourceLayers(resolve_info.dst_subresource);
    vk_resolve_info.dstOffset = toVkOffset3D(resolve_info.dst_offset);
    vk_resolve_info.extent = toVkExtent3D(resolve_info.extent);
    return vk_resolve_info;
}

VkBufferImageCopy toVkBufferImageCopy(const BufferImageCopyInfo& copy_info) {
    VkBufferImageCopy vk_copy_info;
    vk_copy_info.bufferOffset = copy_info.buffer_offset;
    vk_copy_info.bufferRowLength = copy_info.buffer_row_length;
    vk_copy_info.bufferImageHeight = copy_info.buffer_image_height;
    vk_copy_info.imageSubresource = toVkImageSubresourceLayers(copy_info.image_subresource);
    vk_copy_info.imageOffset = toVkOffset3D(copy_info.image_offset);
    vk_copy_info.imageExtent = toVkExtent3D(copy_info.image_extent);
    return vk_copy_info;
}

VkImageSubresourceRange toVkImageSubresourceRange(const ImageSubresourceRange& range) {
    VkImageSubresourceRange vk_range;
    vk_range.aspectMask = helper::toVkImageAspectFlags(range.aspect_mask);
    vk_range.baseMipLevel = range.base_mip_level;
    vk_range.levelCount = range.level_count;
    vk_range.baseArrayLayer = range.base_array_layer;
    vk_range.layerCount = range.layer_count;
    return vk_range;
}

VkMemoryBarrier toVkMemoryBarrier(const MemoryBarrier& barrier) {
    VkMemoryBarrier vk_barrier{};
    vk_barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
    vk_barrier.srcAccessMask = helper::toVkAccessFlags(barrier.src_access_mask);
    vk_barrier.dstAccessMask = helper::toVkAccessFlags(barrier.dst_access_mask);
    return vk_barrier;
}

VkBufferMemoryBarrier toVkBufferMemoryBarrier(const BufferMemoryBarrier& barrier) {
    VkBufferMemoryBarrier vk_barrier{};
    vk_barrier.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
    vk_barrier.srcAccessMask = helper::toVkAccessFlags(barrier.src_access_mask);
    vk_barrier.dstAccessMask = helper::toVkAccessFlags(barrier.dst_access_mask);
    vk_barrier.srcQueueFamilyIndex = barrier.src_queue_family_index;
    vk_barrier.dstQueueFamilyIndex = barrier.dst_queue_family_index;
    auto vk_buffer = RENDER_TYPE_CAST(Buffer, barrier.buffer);
    vk_barrier.buffer = vk_buffer->get();
    vk_barrier.offset = barrier.offset;
    vk_barrier.size = barrier.size;
    return vk_barrier;
}

VkImageMemoryBarrier toVkImageMemoryBarrier(const ImageMemoryBarrier& barrier) {
    VkImageMemoryBarrier vk_barrier{};
    vk_barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    vk_barrier.oldLayout = helper::toVkImageLayout(barrier.old_layout);
    vk_barrier.newLayout = helper::toVkImageLayout(barrier.new_layout);
    vk_barrier.srcQueueFamilyIndex = barrier.src_queue_family_index;
    vk_barrier.dstQueueFamilyIndex = barrier.dst_queue_family_index;
    auto vk_image = RENDER_TYPE_CAST(Image, barrier.image);
    vk_barrier.image = vk_image->get();
    vk_barrier.subresourceRange = toVkImageSubresourceRange(barrier.subresource_range);
    vk_barrier.srcAccessMask = helper::toVkAccessFlags(barrier.src_access_mask);
    vk_barrier.dstAccessMask = helper::toVkAccessFlags(barrier.dst_access_mask);
    return vk_barrier;
}

bool checkValidationLayerSupport() {
    uint32_t layer_count;
    vkEnumerateInstanceLayerProperties(&layer_count, nullptr);

    std::vector<VkLayerProperties> available_layers(layer_count);
    vkEnumerateInstanceLayerProperties(&layer_count, available_layers.data());

    for (const char* layer_name : validation_layers) {
        bool layer_found = false;

        for (const auto& layer_properties : available_layers) {
            if (strcmp(layer_name, layer_properties.layerName) == 0) {
                layer_found = true;
                break;
            }
        }

        if (!layer_found) {
            return false;
        }
    }

    return true;
}

std::vector<const char*> getRequiredExtensions() {
    uint32_t glfw_extensionCount = 0;
    const char** glfw_extensions;
    glfw_extensions = glfwGetRequiredInstanceExtensions(&glfw_extensionCount);

    std::vector<const char*> extensions(glfw_extensions, glfw_extensions + glfw_extensionCount);
    extensions.push_back(VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);

    if (hasEnabledValidationLayers()) {
       extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
    }

    return extensions;
}

static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(
    VkDebugUtilsMessageSeverityFlagBitsEXT message_severity,
    VkDebugUtilsMessageTypeFlagsEXT message_type,
    const VkDebugUtilsMessengerCallbackDataEXT* p_callback_data,
    void* pUserData) {

    std::cerr << "validation layer: " << p_callback_data->pMessage << std::endl;

    return VK_FALSE;
}

VkResult CreateDebugUtilsMessengerEXT(
    const VkInstance& instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pDebugMessenger) {
    auto func = (PFN_vkCreateDebugUtilsMessengerEXT)vkGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
    if (func != nullptr) {
        return func(instance, pCreateInfo, pAllocator, pDebugMessenger);
    }
    else {
        return VK_ERROR_EXTENSION_NOT_PRESENT;
    }
}

void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT& create_info) {
    create_info = {};
    create_info.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
    create_info.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    create_info.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
    create_info.pfnUserCallback = debugCallback;
}

std::shared_ptr<renderer::Instance> createInstance() {
    VkApplicationInfo app_info{};
    app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    app_info.pApplicationName = "Real World";
    app_info.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
    app_info.pEngineName = "No Engine";
    app_info.engineVersion = VK_MAKE_VERSION(1, 0, 0);
    app_info.apiVersion = VK_API_VERSION_1_0;

    VkInstanceCreateInfo create_info{};
    create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    create_info.pApplicationInfo = &app_info;

#if 0
    uint32_t glfw_extensionCount = 0;
    const char** glfw_extensions;

    glfw_extensions = glfwGetRequiredInstanceExtensions(&glfw_extensionCount);

    create_info.enabledExtensionCount = glfw_extensionCount;
    create_info.ppEnabledExtensionNames = glfw_extensions;
    if (enable_validation_layers) {
        create_info.enabledLayerCount = static_cast<uint32_t>(validation_layers.size());
        create_info.ppEnabledLayerNames = validation_layers.data();
    }
    else {
        create_info.enabledLayerCount = 0;
    }
#else
    auto required_extensions = getRequiredExtensions();
    create_info.enabledExtensionCount = static_cast<uint32_t>(required_extensions.size());
    create_info.ppEnabledExtensionNames = required_extensions.data();

    VkDebugUtilsMessengerCreateInfoEXT debug_create_info;
    if (hasEnabledValidationLayers()) {
        create_info.enabledLayerCount = static_cast<uint32_t>(validation_layers.size());
        create_info.ppEnabledLayerNames = validation_layers.data();

        populateDebugMessengerCreateInfo(debug_create_info);
        create_info.pNext = (VkDebugUtilsMessengerCreateInfoEXT*)&debug_create_info;
    }
    else {
        create_info.enabledLayerCount = 0;
        create_info.pNext = nullptr;
    }
#endif
    VkInstance instance;
    auto result = vkCreateInstance(&create_info, nullptr, &instance);
    if (result != VK_SUCCESS) {
        // validation layer doesn't exist.
        if (hasEnabledValidationLayers()) {
            if (result == VK_ERROR_LAYER_NOT_PRESENT) {
                create_info.enabledLayerCount = 0;
                create_info.pNext = nullptr;
                result = vkCreateInstance(&create_info, nullptr, &instance);
                s_enable_validation_layers = false;
            }
            else if (result == VK_ERROR_EXTENSION_NOT_PRESENT) {
                create_info.enabledExtensionCount--;
                result = vkCreateInstance(&create_info, nullptr, &instance);
                s_enable_validation_layers = false;
            }
        }
    }

    if (result != VK_SUCCESS) {
        throw std::runtime_error("failed to create instance!");
    }

    auto vk_instance = std::make_shared<renderer::vk::VulkanInstance>();
    vk_instance->set(instance);

    uint32_t extension_count = 0;
    vkEnumerateInstanceExtensionProperties(nullptr, &extension_count, nullptr);
    std::vector<VkExtensionProperties> extensions(extension_count);
    vkEnumerateInstanceExtensionProperties(nullptr, &extension_count, extensions.data());

    std::cout << "available extensions:\n";

    for (const auto& extension : extensions) {
        std::cout << '\t' << extension.extensionName << '\n';
    }

    if (hasEnabledValidationLayers() && !checkValidationLayerSupport()) {
        throw std::runtime_error("validation layers requested, but not available!");
    }

    if (hasEnabledValidationLayers()) {
        VkDebugUtilsMessengerCreateInfoEXT create_info;
        populateDebugMessengerCreateInfo(create_info);

        VkDebugUtilsMessengerEXT debug_messenger;
        if (CreateDebugUtilsMessengerEXT(instance, &create_info, nullptr, &debug_messenger) != VK_SUCCESS) {
            throw std::runtime_error("failed to set up debug messenger!");
        }

        vk_instance->setDebugMessenger(debug_messenger);
    }

    return vk_instance;
}

std::shared_ptr<renderer::Surface> createSurface(
    const std::shared_ptr<renderer::Instance>& instance,
    GLFWwindow* window) {
    const auto& vk_instance = RENDER_TYPE_CAST(Instance, instance);
    assert(vk_instance);

    VkSurfaceKHR surface;
    if (glfwCreateWindowSurface(vk_instance->get(), window, nullptr, &surface) != VK_SUCCESS) {
        throw std::runtime_error("failed to create window surface!");
    }

    auto vk_surface = std::make_shared<renderer::vk::VulkanSurface>();
    vk_surface->set(surface);
    
    return vk_surface;
}

void DestroyDebugUtilsMessengerEXT(const VkInstance& instance,
    VkDebugUtilsMessengerEXT debug_messenger,
    const VkAllocationCallbacks* pAllocator) {
    auto func = (PFN_vkDestroyDebugUtilsMessengerEXT)vkGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
    if (func != nullptr) {
        func(instance, debug_messenger, pAllocator);
    }
}

renderer::PhysicalDeviceList collectPhysicalDevices(
    const std::shared_ptr<renderer::Instance>& instance) {

    const auto& vk_instance = RENDER_TYPE_CAST(Instance, instance);
    assert(vk_instance);

    uint32_t device_count = 0;
    vkEnumeratePhysicalDevices(vk_instance->get(), &device_count, nullptr);

    if (device_count == 0) {
        throw std::runtime_error("failed to find GPUs with Vulkan support!");
    }

    std::vector<VkPhysicalDevice> devices(device_count);
    vkEnumeratePhysicalDevices(vk_instance->get(), &device_count, devices.data());

    renderer::PhysicalDeviceList physical_devices;

    for (const auto& device : devices) {
        auto physical_device = std::make_shared<renderer::vk::VulkanPhysicalDevice>();
        physical_device->set(device);
        physical_devices.push_back(physical_device);
    }

    return physical_devices;
}

renderer::QueueFamilyIndices findQueueFamilies(
    const std::shared_ptr<renderer::PhysicalDevice>& physical_device,
    const std::shared_ptr<renderer::Surface>& surface) {
    renderer::QueueFamilyIndices indices;

    const auto& vk_physical_device = RENDER_TYPE_CAST(PhysicalDevice, physical_device);
    assert(vk_physical_device);
    auto device = vk_physical_device->get();

    auto vk_surface = RENDER_TYPE_CAST(Surface, surface);
    assert(vk_surface);

    uint32_t queue_family_count = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queue_family_count, nullptr);

    std::vector<VkQueueFamilyProperties> queue_families(queue_family_count);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &queue_family_count, queue_families.data());

    int i = 0;
    for (const auto& queue_family : queue_families) {
        if (queue_family.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
            indices.graphics_family_ = i;
        }

        VkBool32 present_support = false;
        vkGetPhysicalDeviceSurfaceSupportKHR(device, i, vk_surface->get(), &present_support);

        if (present_support) {
            indices.present_family_ = i;
        }
        if (indices.isComplete()) {
            break;
        }

        i++;
    }

    return indices;
}

bool checkDeviceExtensionSupport(
    const std::shared_ptr<renderer::PhysicalDevice>& physical_device) {
    const auto& vk_physical_device = RENDER_TYPE_CAST(PhysicalDevice, physical_device);
    assert(vk_physical_device);
    auto device = vk_physical_device->get();

    uint32_t extension_count;
    vkEnumerateDeviceExtensionProperties(device, nullptr, &extension_count, nullptr);

    std::vector<VkExtensionProperties> available_extensions(extension_count);
    vkEnumerateDeviceExtensionProperties(device, nullptr, &extension_count, available_extensions.data());

    std::set<std::string> required_extensions(device_extensions.begin(), device_extensions.end());

    for (const auto& extension : available_extensions) {
        required_extensions.erase(extension.extensionName);
    }

    return required_extensions.empty();
}

SwapChainSupportDetails querySwapChainSupport(
    const std::shared_ptr<renderer::PhysicalDevice>& physical_device,
    const std::shared_ptr<renderer::Surface>& surface) {
    SwapChainSupportDetails details;

    auto vk_device = RENDER_TYPE_CAST(PhysicalDevice, physical_device);
    assert(vk_device);
    auto device = vk_device->get();

    auto vk_surface = RENDER_TYPE_CAST(Surface, surface);
    assert(vk_surface);

    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, vk_surface->get(), &details.capabilities_);

    uint32_t format_count;
    vkGetPhysicalDeviceSurfaceFormatsKHR(device, vk_surface->get(), &format_count, nullptr);

    if (format_count != 0) {
        details.formats_.resize(format_count);
        vkGetPhysicalDeviceSurfaceFormatsKHR(device, vk_surface->get(), &format_count, details.formats_.data());
    }

    uint32_t present_mode_count;
    vkGetPhysicalDeviceSurfacePresentModesKHR(device, vk_surface->get(), &present_mode_count, nullptr);

    if (present_mode_count != 0) {
        details.present_modes_.resize(present_mode_count);
        vkGetPhysicalDeviceSurfacePresentModesKHR(device, vk_surface->get(), &present_mode_count, details.present_modes_.data());
    }

    return details;
}

//--------------------------------------------------------------------------------------------------
// Initialize Vulkan ray tracing
// #VKRay
void initRayTracing(const VkPhysicalDevice& device)
{
    VkPhysicalDeviceRayTracingPipelinePropertiesKHR
        rt_properties{
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR };

    // Requesting ray tracing properties
    VkPhysicalDeviceProperties2 prop2{ VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 };
    prop2.pNext = &rt_properties;
    vkGetPhysicalDeviceProperties2(device, &prop2);

    VkPhysicalDeviceAccelerationStructureFeaturesKHR as_features{};
    as_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
    VkPhysicalDeviceFeatures2 device_features2{};
    device_features2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
    device_features2.pNext = &as_features;
    vkGetPhysicalDeviceFeatures2(device, &device_features2);
}

bool isDeviceSuitable(
    const std::shared_ptr<renderer::PhysicalDevice>& physical_device,
    const std::shared_ptr<renderer::Surface>& surface) {
    renderer::QueueFamilyIndices indices = findQueueFamilies(physical_device, surface);

    const auto& vk_physical_device = RENDER_TYPE_CAST(PhysicalDevice, physical_device);
    assert(vk_physical_device);
    auto device = vk_physical_device->get();

    initRayTracing(device);

    bool extensions_supported = checkDeviceExtensionSupport(physical_device);

    bool swap_chain_adequate = false;
    if (extensions_supported) {
        SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physical_device, surface);
        swap_chain_adequate = !swapChainSupport.formats_.empty() && !swapChainSupport.present_modes_.empty();
    }

    VkPhysicalDeviceFeatures supported_features;
    vkGetPhysicalDeviceFeatures(device, &supported_features);

    return indices.isComplete() && extensions_supported && swap_chain_adequate && supported_features.samplerAnisotropy;
}

std::shared_ptr<renderer::PhysicalDevice> pickPhysicalDevice(
    const renderer::PhysicalDeviceList& physical_devices,
    const std::shared_ptr<renderer::Surface>& surface) {
    
    std::shared_ptr<renderer::PhysicalDevice> picked_device;
#if 0
    // Use an ordered map to automatically sort candidates by increasing score
    std::multimap<int, VkPhysicalDevice> candidates;

    for (const auto& device : devices) {
        int score = rateDeviceSuitability(device);
        candidates.insert(std::make_pair(score, device));
    }

    // Check if the best candidate is suitable at all
    if (candidates.rbegin()->first > 0) {
        vk_physical_device_ = candidates.rbegin()->second;
    }
    else {
        throw std::runtime_error("failed to find a suitable GPU!");
    }
#else
    for (const auto& device : physical_devices) {
        if (isDeviceSuitable(device, surface)) {
            picked_device = device;
            //break;
        }
    }

    if (picked_device == VK_NULL_HANDLE) {
        throw std::runtime_error("failed to find a suitable GPU!");
    }
#endif

    return picked_device;
}

std::shared_ptr<renderer::Device> createLogicalDevice(
    const std::shared_ptr<renderer::PhysicalDevice>& physical_device,
    const std::shared_ptr<renderer::Surface>& surface,
    const renderer::QueueFamilyIndices& indices) {

    std::vector<VkDeviceQueueCreateInfo> queue_create_infos;
    std::set<uint32_t> unique_queue_families = { indices.graphics_family_.value(), indices.present_family_.value() };

    float queue_priority = 1.0f;
    for (uint32_t queue_family : unique_queue_families) {
        VkDeviceQueueCreateInfo queue_create_info{};
        queue_create_info.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        queue_create_info.queueFamilyIndex = queue_family;
        queue_create_info.queueCount = 1;
        queue_create_info.pQueuePriorities = &queue_priority;
        queue_create_infos.push_back(queue_create_info);
    }

    VkPhysicalDeviceFeatures device_features{};
    device_features.samplerAnisotropy = VK_TRUE;
    device_features.geometryShader = VK_TRUE;
    device_features.imageCubeArray = VK_TRUE;
    device_features.shaderInt16 = VK_TRUE;
    device_features.multiDrawIndirect = VK_TRUE;
    device_features.multiViewport = VK_TRUE;

    VkDeviceCreateInfo create_info{};
    create_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;

    create_info.queueCreateInfoCount = static_cast<uint32_t>(queue_create_infos.size());
    create_info.pQueueCreateInfos = queue_create_infos.data();

    create_info.pEnabledFeatures = &device_features;

    create_info.enabledExtensionCount = 0;

    if (hasEnabledValidationLayers()) {
        create_info.enabledLayerCount = static_cast<uint32_t>(validation_layers.size());
        create_info.ppEnabledLayerNames = validation_layers.data();
    }
    else {
        create_info.enabledLayerCount = 0;
    }

    create_info.enabledExtensionCount = static_cast<uint32_t>(device_extensions.size());
    create_info.ppEnabledExtensionNames = device_extensions.data();

    VkPhysicalDeviceBufferDeviceAddressFeatures enabled_buffer_device_address_features{};
    VkPhysicalDeviceRayTracingPipelineFeaturesKHR enabled_ray_tracing_pipeline_features{};
    VkPhysicalDeviceAccelerationStructureFeaturesKHR enabled_acceleration_structure_features{};

    // Enable features required for ray tracing using feature chaining via pNext		
    enabled_buffer_device_address_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
    enabled_buffer_device_address_features.bufferDeviceAddress = VK_TRUE;

    enabled_ray_tracing_pipeline_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
    enabled_ray_tracing_pipeline_features.rayTracingPipeline = VK_TRUE;
    enabled_ray_tracing_pipeline_features.pNext = &enabled_buffer_device_address_features;

    enabled_acceleration_structure_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
    enabled_acceleration_structure_features.accelerationStructure = VK_TRUE;
    enabled_acceleration_structure_features.pNext = &enabled_ray_tracing_pipeline_features;

    // If a pNext(Chain) has been passed, we need to add it to the device creation info
    VkPhysicalDeviceFeatures2 physical_device_features2{};
    physical_device_features2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
    physical_device_features2.features = device_features;
    physical_device_features2.pNext = &enabled_acceleration_structure_features;
    create_info.pEnabledFeatures = nullptr;
    create_info.pNext = &physical_device_features2;

    const auto& vk_physical_device = RENDER_TYPE_CAST(PhysicalDevice, physical_device);
    assert(vk_physical_device);
    VkDevice vk_device;
    if (vkCreateDevice(vk_physical_device->get(), &create_info, nullptr, &vk_device) != VK_SUCCESS) {
        throw std::runtime_error("failed to create logical device!");
    }

    auto vk_logic_device = std::make_shared<renderer::vk::VulkanDevice>(physical_device, vk_device);
    return vk_logic_device;
}

void initRayTracingProperties(
    const std::shared_ptr<renderer::PhysicalDevice>& physical_device,
    const std::shared_ptr<renderer::Device>& device,
    PhysicalDeviceRayTracingPipelineProperties& rt_pipeline_properties,
    PhysicalDeviceAccelerationStructureFeatures& as_features) {
    const auto& vk_physical_device = RENDER_TYPE_CAST(PhysicalDevice, physical_device)->get();
    const auto& vk_device = RENDER_TYPE_CAST(Device, device)->get();

    // Get the ray tracing and accelertion structure related function pointers required by this sample
    vkGetBufferDeviceAddressKHR = reinterpret_cast<PFN_vkGetBufferDeviceAddressKHR>(vkGetDeviceProcAddr(vk_device, "vkGetBufferDeviceAddressKHR"));
    vkCmdBuildAccelerationStructuresKHR = reinterpret_cast<PFN_vkCmdBuildAccelerationStructuresKHR>(vkGetDeviceProcAddr(vk_device, "vkCmdBuildAccelerationStructuresKHR"));
    vkBuildAccelerationStructuresKHR = reinterpret_cast<PFN_vkBuildAccelerationStructuresKHR>(vkGetDeviceProcAddr(vk_device, "vkBuildAccelerationStructuresKHR"));
    vkCreateAccelerationStructureKHR = reinterpret_cast<PFN_vkCreateAccelerationStructureKHR>(vkGetDeviceProcAddr(vk_device, "vkCreateAccelerationStructureKHR"));
    vkDestroyAccelerationStructureKHR = reinterpret_cast<PFN_vkDestroyAccelerationStructureKHR>(vkGetDeviceProcAddr(vk_device, "vkDestroyAccelerationStructureKHR"));
    vkGetAccelerationStructureBuildSizesKHR = reinterpret_cast<PFN_vkGetAccelerationStructureBuildSizesKHR>(vkGetDeviceProcAddr(vk_device, "vkGetAccelerationStructureBuildSizesKHR"));
    vkGetAccelerationStructureDeviceAddressKHR = reinterpret_cast<PFN_vkGetAccelerationStructureDeviceAddressKHR>(vkGetDeviceProcAddr(vk_device, "vkGetAccelerationStructureDeviceAddressKHR"));
    vkCmdTraceRaysKHR = reinterpret_cast<PFN_vkCmdTraceRaysKHR>(vkGetDeviceProcAddr(vk_device, "vkCmdTraceRaysKHR"));
    vkGetRayTracingShaderGroupHandlesKHR = reinterpret_cast<PFN_vkGetRayTracingShaderGroupHandlesKHR>(vkGetDeviceProcAddr(vk_device, "vkGetRayTracingShaderGroupHandlesKHR"));
    vkCreateRayTracingPipelinesKHR = reinterpret_cast<PFN_vkCreateRayTracingPipelinesKHR>(vkGetDeviceProcAddr(vk_device, "vkCreateRayTracingPipelinesKHR"));

    // Get ray tracing pipeline properties, which will be used later on in the sample
    VkPhysicalDeviceRayTracingPipelinePropertiesKHR  ray_tracing_pipeline_properties{};
    VkPhysicalDeviceAccelerationStructureFeaturesKHR acceleration_structure_features{};

    ray_tracing_pipeline_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
    VkPhysicalDeviceProperties2 device_properties2{};
    device_properties2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
    device_properties2.pNext = &ray_tracing_pipeline_properties;
    vkGetPhysicalDeviceProperties2(vk_physical_device, &device_properties2);
    rt_pipeline_properties.max_ray_dispatch_invocation_count = ray_tracing_pipeline_properties.maxRayDispatchInvocationCount;
    rt_pipeline_properties.max_ray_hit_attribute_size = ray_tracing_pipeline_properties.maxRayHitAttributeSize;
    rt_pipeline_properties.max_ray_recursion_depth = ray_tracing_pipeline_properties.maxRayRecursionDepth;
    rt_pipeline_properties.max_shader_group_stride = ray_tracing_pipeline_properties.maxShaderGroupStride;
    rt_pipeline_properties.shader_group_base_alignment = ray_tracing_pipeline_properties.shaderGroupBaseAlignment;
    rt_pipeline_properties.shader_group_handle_alignment = ray_tracing_pipeline_properties.shaderGroupHandleAlignment;
    rt_pipeline_properties.shader_group_handle_capture_replay_size = ray_tracing_pipeline_properties.shaderGroupHandleCaptureReplaySize;
    rt_pipeline_properties.shader_group_handle_size = ray_tracing_pipeline_properties.shaderGroupHandleSize;

    // Get acceleration structure properties, which will be used later on in the sample
    acceleration_structure_features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
    VkPhysicalDeviceFeatures2 device_features2{};
    device_features2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
    device_features2.pNext = &acceleration_structure_features;
    vkGetPhysicalDeviceFeatures2(vk_physical_device, &device_features2);
    as_features.acceleration_structure = acceleration_structure_features.accelerationStructure;
    as_features.acceleration_structure_capture_replay = acceleration_structure_features.accelerationStructureCaptureReplay;
    as_features.acceleration_structure_host_commands = acceleration_structure_features.accelerationStructureHostCommands;
    as_features.acceleration_structure_indirect_build = acceleration_structure_features.accelerationStructureIndirectBuild;
    as_features.descriptor_binding_acceleration_structure_update_after_bind = acceleration_structure_features.descriptorBindingAccelerationStructureUpdateAfterBind;
}

int rateDeviceSuitability(const VkPhysicalDevice& device) {
    VkPhysicalDeviceProperties device_properties;
    VkPhysicalDeviceFeatures device_features;
    vkGetPhysicalDeviceProperties(device, &device_properties);
    vkGetPhysicalDeviceFeatures(device, &device_features);

    int score = 0;

    // Discrete GPUs have a significant performance advantage
    if (device_properties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
        score += 1000;
    }

    // Maximum possible size of textures affects graphics quality
    score += device_properties.limits.maxImageDimension2D;
    max_vertex_input_attribute_offset = device_properties.limits.maxVertexInputAttributeOffset;

    // Application can't function without geometry shaders
    if (!device_features.geometryShader) {
        return 0;
    }

    return score;
}

VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& available_formats) {
    for (const auto& available_format : available_formats) {
        if (available_format.format == VK_FORMAT_B8G8R8A8_UNORM &&
            available_format.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
            return available_format;
        }
    }

    return available_formats[0];
}

renderer::PresentMode chooseSwapPresentMode(const std::vector<VkPresentModeKHR>& availablePresentModes) {
    for (const auto& availablePresentMode : availablePresentModes) {
        if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) {
            return renderer::PresentMode::MAILBOX_KHR;
        }
    }

    return renderer::PresentMode::FIFO_KHR;
}

VkExtent2D chooseSwapExtent(GLFWwindow* window, const VkSurfaceCapabilitiesKHR& capabilities) {
    if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
        return capabilities.currentExtent;
    }
    else {
        int width, height;
        glfwGetFramebufferSize(window, &width, &height);
        VkExtent2D actualExtent = { static_cast<uint32_t>(width), static_cast<uint32_t>(height) };
        actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width));
        actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height));

        return actualExtent;
    }
}

renderer::Format findSupportedFormat(
    const std::shared_ptr<renderer::PhysicalDevice>& physical_device,
    const std::vector<renderer::Format>& candidates,
    const VkImageTiling& tiling,
    const VkFormatFeatureFlags& features) {
    const auto& vk_physical_device = RENDER_TYPE_CAST(PhysicalDevice, physical_device);
    assert(vk_physical_device);
    for (auto format : candidates) {
        VkFormatProperties props;
        auto vk_format = toVkFormat(format);
        vkGetPhysicalDeviceFormatProperties(vk_physical_device->get(), vk_format, &props);
        if (tiling == VK_IMAGE_TILING_LINEAR && (props.linearTilingFeatures & features) == features) {
            return format;
        }
        else if (tiling == VK_IMAGE_TILING_OPTIMAL && (props.optimalTilingFeatures & features) == features) {
            return format;
        }
    }

    throw std::runtime_error("failed to find supported format!");
}

renderer::Format findDepthFormat(
    const std::shared_ptr<renderer::Device>& device) {
    auto vk_device = RENDER_TYPE_CAST(Device, device);
    return findSupportedFormat(vk_device->getPhysicalDevice(),
        { renderer::Format::D32_SFLOAT,
          renderer::Format::D32_SFLOAT_S8_UINT,
          renderer::Format::D24_UNORM_S8_UINT,
          renderer::Format::D16_UNORM_S8_UINT,
          renderer::Format::D16_UNORM },
        VK_IMAGE_TILING_OPTIMAL,
        VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
    );
}

bool isDepthFormat(const renderer::Format& format) {
    return (format == renderer::Format::D32_SFLOAT_S8_UINT ||
        format == renderer::Format::D32_SFLOAT ||
        format == renderer::Format::D24_UNORM_S8_UINT ||
        format == renderer::Format::D16_UNORM_S8_UINT ||
        format == renderer::Format::D16_UNORM);
}

std::vector<VkPipelineShaderStageCreateInfo> getShaderStages(
    const ShaderModuleList& shader_modules) {
    std::vector<VkPipelineShaderStageCreateInfo> shader_stages(shader_modules.size());

    for (auto i = 0; i < shader_modules.size(); i++) {
        auto vk_shader_module = RENDER_TYPE_CAST(ShaderModule, shader_modules[i]);
        shader_stages[i].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        shader_stages[i].stage = helper::toVkShaderStageFlagBits(vk_shader_module->getShaderStage());
        shader_stages[i].module = vk_shader_module->get();
        shader_stages[i].pName = "main";
    }

    return shader_stages;
}

std::vector<VkRayTracingShaderGroupCreateInfoKHR> getShaderGroups(
    const RtShaderGroupCreateInfoList& src_shader_groups) {
    std::vector<VkRayTracingShaderGroupCreateInfoKHR> shader_groups(src_shader_groups.size());

    for (auto i = 0; i < src_shader_groups.size(); i++) {
        shader_groups[i].sType = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;
        shader_groups[i].type = toVkRayTracingShaderGroupType(src_shader_groups[i].type);
        shader_groups[i].generalShader = src_shader_groups[i].general_shader;
        shader_groups[i].anyHitShader = src_shader_groups[i].any_hit_shader;
        shader_groups[i].closestHitShader = src_shader_groups[i].closest_hit_shader;
        shader_groups[i].intersectionShader = src_shader_groups[i].intersection_shader;
        shader_groups[i].pShaderGroupCaptureReplayHandle = src_shader_groups[i].p_shader_group_capture_replay_handle;
    }

    return shader_groups;
}

uint32_t findMemoryType(
    const std::shared_ptr<renderer::PhysicalDevice>& physical_device,
    uint32_t type_filter,
    VkMemoryPropertyFlags properties) {

    auto vk_physical_device = RENDER_TYPE_CAST(PhysicalDevice, physical_device);
    assert(vk_physical_device);
    VkPhysicalDeviceMemoryProperties mem_properties;
    vkGetPhysicalDeviceMemoryProperties(vk_physical_device->get(), &mem_properties);

    for (uint32_t i = 0; i < mem_properties.memoryTypeCount; i++) {
        if ((type_filter & (1 << i)) && (mem_properties.memoryTypes[i].propertyFlags & properties) == properties) {
            return i;
        }
    }

    throw std::runtime_error("failed to find suitable memory type!");
}

VkWriteDescriptorSet addDescriptWrite(
    const VkDescriptorSet& description_set,
    const VkDescriptorImageInfo* image_info,
    uint32_t binding,
    const VkDescriptorType& desc_type/* = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER*/) {
    VkWriteDescriptorSet result = {};
    result.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    result.dstSet = description_set;
    result.dstBinding = binding;
    result.dstArrayElement = 0;
    result.descriptorType = desc_type;
    result.descriptorCount = 1;
    result.pImageInfo = image_info;

    return result;
}

void createTextureImage(
    const std::shared_ptr<renderer::Device>& device,
    const glm::vec3& tex_size,
    const renderer::Format& format,
    const renderer::ImageTiling& tiling,
    const renderer::ImageUsageFlags& usage,
    const renderer::MemoryPropertyFlags& properties,
    std::shared_ptr<renderer::Image>& image,
    std::shared_ptr<renderer::DeviceMemory>& image_memory) {
    image = device->createImage(
        tex_size.z > 1 ?
            renderer::ImageType::TYPE_3D :
            renderer::ImageType::TYPE_2D,
        tex_size,
        format,
        usage,
        tiling,
        renderer::ImageLayout::UNDEFINED);
    auto mem_requirements = device->getImageMemoryRequirements(image);
    image_memory = device->allocateMemory(mem_requirements.size,
        mem_requirements.memory_type_bits,
        toVkMemoryPropertyFlags(properties),
        0);
    device->bindImageMemory(image, image_memory);
}

void copyBuffer(
    const renderer::DeviceInfo& device_info,
    const std::shared_ptr<renderer::Buffer>& src_buffer,
    const std::shared_ptr<renderer::Buffer>& dst_buffer,
    uint64_t buffer_size) {

    const auto& device = device_info.device;
    const auto& cmd_queue = device_info.cmd_queue;
    const auto& cmd_pool = device_info.cmd_pool;

    auto command_buffers = device->allocateCommandBuffers(cmd_pool, 1);
    if (command_buffers.size() > 0) {
        auto& cmd_buf = command_buffers[0];
        if (cmd_buf) {
            cmd_buf->beginCommandBuffer(SET_FLAG_BIT(CommandBufferUsage, ONE_TIME_SUBMIT_BIT));

            std::vector<renderer::BufferCopyInfo> copy_regions(1);
            copy_regions[0].src_offset = 0; // Optional
            copy_regions[0].dst_offset = 0; // Optional
            copy_regions[0].size = buffer_size;
            cmd_buf->copyBuffer(src_buffer, dst_buffer, copy_regions);

            cmd_buf->endCommandBuffer();
        }

        cmd_queue->submit(command_buffers);
        cmd_queue->waitIdle();
        device->freeCommandBuffers(cmd_pool, command_buffers);
    }
}

bool hasStencilComponent(const renderer::Format& format) {
    return format == renderer::Format::D32_SFLOAT_S8_UINT ||
        format == renderer::Format::D24_UNORM_S8_UINT ||
        format == renderer::Format::D16_UNORM_S8_UINT;
}

void transitionImageLayout(
    const renderer::DeviceInfo& device_info,
    const std::shared_ptr<renderer::Image>& image,
    const renderer::Format& format,
    const renderer::ImageLayout& old_layout,
    const renderer::ImageLayout& new_layout,
    uint32_t base_mip_idx/* = 0*/,
    uint32_t mip_count/* = 1*/,
    uint32_t base_layer/* = 0*/,
    uint32_t layer_count/* = 1*/) {

    const auto& device = device_info.device;
    const auto& cmd_queue = device_info.cmd_queue;
    const auto& cmd_pool = device_info.cmd_pool;
    assert(device);
    assert(cmd_queue);
    assert(cmd_pool);

    auto command_buffers = device_info.device->allocateCommandBuffers(cmd_pool, 1);
    if (command_buffers.size() > 0) {
        auto& cmd_buf = command_buffers[0];
        if (cmd_buf) {
            cmd_buf->beginCommandBuffer(SET_FLAG_BIT(CommandBufferUsage, ONE_TIME_SUBMIT_BIT));

            VkImageMemoryBarrier barrier{};
            barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
            barrier.oldLayout = toVkImageLayout(old_layout);
            barrier.newLayout = toVkImageLayout(new_layout);
            barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
            barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;

            // todo.
            auto vk_image = RENDER_TYPE_CAST(Image, image);
            barrier.image = vk_image->get();
            if (isDepthFormat(format)) {
                barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;

                if (hasStencilComponent(format)) {
                    barrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT;
                }
            }
            else {
                barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
            }
            barrier.subresourceRange.baseMipLevel = base_mip_idx;
            barrier.subresourceRange.levelCount = mip_count;
            barrier.subresourceRange.baseArrayLayer = base_layer;
            barrier.subresourceRange.layerCount = layer_count;
            VkPipelineStageFlags source_stage;
            VkPipelineStageFlags destination_stage;

            if (old_layout == renderer::ImageLayout::UNDEFINED &&
                new_layout == renderer::ImageLayout::TRANSFER_DST_OPTIMAL) {
                barrier.srcAccessMask = 0;
                barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

                source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
                destination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
            }
            else if (old_layout == renderer::ImageLayout::UNDEFINED &&
                new_layout == renderer::ImageLayout::TRANSFER_SRC_OPTIMAL) {
                barrier.srcAccessMask = 0;
                barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;

                source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
                destination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
            }
            else if (old_layout == renderer::ImageLayout::TRANSFER_DST_OPTIMAL &&
                new_layout == renderer::ImageLayout::SHADER_READ_ONLY_OPTIMAL) {
                barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
                barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

                source_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
                destination_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
            }
            else if (old_layout == renderer::ImageLayout::TRANSFER_SRC_OPTIMAL &&
                new_layout == renderer::ImageLayout::SHADER_READ_ONLY_OPTIMAL) {
                barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
                barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

                source_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
                destination_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
            }
            else if (old_layout == renderer::ImageLayout::UNDEFINED &&
                new_layout == renderer::ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL) {
                barrier.srcAccessMask = 0;
                barrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

                source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
                destination_stage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
            }
            else if (old_layout == renderer::ImageLayout::UNDEFINED &&
                new_layout == renderer::ImageLayout::COLOR_ATTACHMENT_OPTIMAL) {
                barrier.srcAccessMask = 0;
                barrier.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

                source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
                destination_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
            }
            else if (old_layout == renderer::ImageLayout::UNDEFINED &&
                new_layout == renderer::ImageLayout::SHADER_READ_ONLY_OPTIMAL) {
                barrier.srcAccessMask = 0;
                barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

                source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
                destination_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT |
                    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;
            }
            else if (old_layout == renderer::ImageLayout::UNDEFINED &&
                new_layout == renderer::ImageLayout::PRESENT_SRC_KHR) {
                barrier.srcAccessMask = 0;
                barrier.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

                source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
                destination_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
            }
            else if (old_layout == renderer::ImageLayout::UNDEFINED &&
                new_layout == renderer::ImageLayout::GENERAL) {
                barrier.srcAccessMask = 0;
                barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT| VK_ACCESS_SHADER_WRITE_BIT;

                source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
                destination_stage = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;
            }
            else {
                throw std::invalid_argument("unsupported layout transition!");
            }

            auto vk_cmd_Buf = RENDER_TYPE_CAST(CommandBuffer, cmd_buf);
            assert(vk_cmd_Buf);
            vkCmdPipelineBarrier(
                vk_cmd_Buf->get(),
                source_stage, destination_stage,
                0,
                0, nullptr,
                0, nullptr,
                1, &barrier
            );

            cmd_buf->endCommandBuffer();
        }

        cmd_queue->submit(command_buffers);
        cmd_queue->waitIdle();
        device->freeCommandBuffers(cmd_pool, command_buffers);
    }
}

void copyBufferToImageWithMips(
    const renderer::DeviceInfo& device_info,
    const std::shared_ptr<renderer::Buffer>& buffer,
    const std::shared_ptr<renderer::Image>& image,
    const std::vector<renderer::BufferImageCopyInfo>& copy_regions) {
    const auto& device = device_info.device;
    const auto& cmd_queue = device_info.cmd_queue;
    const auto& cmd_pool = device_info.cmd_pool;

    auto command_buffers = device->allocateCommandBuffers(cmd_pool, 1);
    if (command_buffers.size() > 0) {
        auto& cmd_buf = command_buffers[0];
        if (cmd_buf) {
            cmd_buf->beginCommandBuffer(SET_FLAG_BIT(CommandBufferUsage, ONE_TIME_SUBMIT_BIT));
            cmd_buf->copyBufferToImage(buffer, image, copy_regions, renderer::ImageLayout::TRANSFER_DST_OPTIMAL);
            cmd_buf->endCommandBuffer();
        }

        cmd_queue->submit(command_buffers);
        cmd_queue->waitIdle();
        device->freeCommandBuffers(cmd_pool, command_buffers);
    }
}

void copyImageToBufferWithMips(
    const renderer::DeviceInfo& device_info,
    const std::shared_ptr<renderer::Image>& image,
    const std::shared_ptr<renderer::Buffer>& buffer,
    const std::vector<renderer::BufferImageCopyInfo>& copy_regions) {
    const auto& device = device_info.device;
    const auto& cmd_queue = device_info.cmd_queue;
    const auto& cmd_pool = device_info.cmd_pool;

    auto command_buffers = device->allocateCommandBuffers(cmd_pool, 1);
    if (command_buffers.size() > 0) {
        auto& cmd_buf = command_buffers[0];
        if (cmd_buf) {
            cmd_buf->beginCommandBuffer(SET_FLAG_BIT(CommandBufferUsage, ONE_TIME_SUBMIT_BIT));
            cmd_buf->copyImageToBuffer(image, buffer, copy_regions, renderer::ImageLayout::TRANSFER_SRC_OPTIMAL);
            cmd_buf->endCommandBuffer();
        }

        cmd_queue->submit(command_buffers);
        cmd_queue->waitIdle();
        device->freeCommandBuffers(cmd_pool, command_buffers);
    }
}

void copyBufferToImage(
    const renderer::DeviceInfo& device_info,
    const std::shared_ptr<renderer::Buffer>& buffer,
    const std::shared_ptr<renderer::Image>& image,
    const glm::uvec3& tex_size) {
    std::vector<renderer::BufferImageCopyInfo> copy_regions(1);
    auto& region = copy_regions[0];
    region.buffer_offset = 0;
    region.buffer_row_length = 0;
    region.buffer_image_height = 0;

    region.image_subresource.aspect_mask = SET_FLAG_BIT(ImageAspect, COLOR_BIT);
    region.image_subresource.mip_level = 0;
    region.image_subresource.base_array_layer = 0;
    region.image_subresource.layer_count = 1;

    region.image_offset = glm::ivec3(0, 0, 0);
    region.image_extent = tex_size;

    copyBufferToImageWithMips(device_info, buffer, image, copy_regions);
}

void copyImageToBuffer(
    const renderer::DeviceInfo& device_info,
    const std::shared_ptr<renderer::Image>& image,
    const std::shared_ptr<renderer::Buffer>& buffer,
    const glm::uvec3& tex_size) {
    std::vector<renderer::BufferImageCopyInfo> copy_regions(1);
    auto& region = copy_regions[0];
    region.buffer_offset = 0;
    region.buffer_row_length = 0;
    region.buffer_image_height = 0;

    region.image_subresource.aspect_mask = SET_FLAG_BIT(ImageAspect, COLOR_BIT);
    region.image_subresource.mip_level = 0;
    region.image_subresource.base_array_layer = 0;
    region.image_subresource.layer_count = 1;

    region.image_offset = glm::ivec3(0, 0, 0);
    region.image_extent = tex_size;

    copyImageToBufferWithMips(device_info, image, buffer, copy_regions);
}


void generateMipmapLevels(
    const std::shared_ptr<renderer::CommandBuffer>& cmd_buf,
    const std::shared_ptr<renderer::Image>& image,
    uint32_t mip_count,
    uint32_t width,
    uint32_t height,
    const renderer::ImageLayout& cur_image_layout)
{
    auto vk_cmd_buf = RENDER_TYPE_CAST(CommandBuffer, cmd_buf);
    auto vk_image = RENDER_TYPE_CAST(Image, image);

    BarrierList barrier_list;
    barrier_list.image_barriers.resize(1);
    barrier_list.image_barriers[0].image = image;
    barrier_list.image_barriers[0].old_layout = cur_image_layout;
    barrier_list.image_barriers[0].new_layout = renderer::ImageLayout::TRANSFER_SRC_OPTIMAL;
    barrier_list.image_barriers[0].src_access_mask = SET_FLAG_BIT(Access, COLOR_ATTACHMENT_WRITE_BIT);
    barrier_list.image_barriers[0].dst_access_mask = SET_FLAG_BIT(Access, TRANSFER_READ_BIT);
    barrier_list.image_barriers[0].subresource_range =
        { SET_FLAG_BIT(ImageAspect, COLOR_BIT), 0, 1, 0, 6 };
    cmd_buf->addBarriers(
        barrier_list,
        SET_FLAG_BIT(PipelineStage, COLOR_ATTACHMENT_OUTPUT_BIT),
        SET_FLAG_BIT(PipelineStage, TRANSFER_BIT));

    for (uint32_t i = 1; i < mip_count; i++)
    {
        VkImageBlit imageBlit{};

        // Source
        imageBlit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        imageBlit.srcSubresource.layerCount = 6u;
        imageBlit.srcSubresource.mipLevel = i - 1;
        imageBlit.srcOffsets[1].x = int32_t(width >> (i - 1));
        imageBlit.srcOffsets[1].y = int32_t(height >> (i - 1));
        imageBlit.srcOffsets[1].z = 1;

        // Destination
        imageBlit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        imageBlit.dstSubresource.layerCount = 6u;
        imageBlit.dstSubresource.mipLevel = i;
        imageBlit.dstOffsets[1].x = int32_t(width >> i);
        imageBlit.dstOffsets[1].y = int32_t(height >> i);
        imageBlit.dstOffsets[1].z = 1;

        barrier_list.image_barriers[0].old_layout = renderer::ImageLayout::UNDEFINED;
        barrier_list.image_barriers[0].new_layout = renderer::ImageLayout::TRANSFER_DST_OPTIMAL;
        barrier_list.image_barriers[0].src_access_mask = SET_FLAG_BIT(Access, COLOR_ATTACHMENT_WRITE_BIT);
        barrier_list.image_barriers[0].dst_access_mask = SET_FLAG_BIT(Access, TRANSFER_WRITE_BIT);
        barrier_list.image_barriers[0].subresource_range =
        { SET_FLAG_BIT(ImageAspect, COLOR_BIT), i, 1, 0, 6 };
        cmd_buf->addBarriers(
            barrier_list,
            SET_FLAG_BIT(PipelineStage, COLOR_ATTACHMENT_OUTPUT_BIT),
            SET_FLAG_BIT(PipelineStage, TRANSFER_BIT));

        vkCmdBlitImage(
            vk_cmd_buf->get(),
            vk_image->get(),
            VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
            vk_image->get(),
            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
            1,
            &imageBlit,
            VK_FILTER_LINEAR);

        barrier_list.image_barriers[0].old_layout = renderer::ImageLayout::TRANSFER_DST_OPTIMAL;
        barrier_list.image_barriers[0].new_layout = renderer::ImageLayout::TRANSFER_SRC_OPTIMAL;
        barrier_list.image_barriers[0].src_access_mask = SET_FLAG_BIT(Access, TRANSFER_WRITE_BIT);
        barrier_list.image_barriers[0].dst_access_mask = SET_FLAG_BIT(Access, TRANSFER_READ_BIT);
        barrier_list.image_barriers[0].subresource_range =
        { SET_FLAG_BIT(ImageAspect, COLOR_BIT), i, 1, 0, 6 };
        cmd_buf->addBarriers(
            barrier_list,
            SET_FLAG_BIT(PipelineStage, TRANSFER_BIT),
            SET_FLAG_BIT(PipelineStage, TRANSFER_BIT));
    }

    {
        barrier_list.image_barriers[0].old_layout = renderer::ImageLayout::TRANSFER_SRC_OPTIMAL;
        barrier_list.image_barriers[0].new_layout = renderer::ImageLayout::SHADER_READ_ONLY_OPTIMAL;
        barrier_list.image_barriers[0].src_access_mask = SET_FLAG_BIT(Access, TRANSFER_READ_BIT);
        barrier_list.image_barriers[0].dst_access_mask = SET_FLAG_BIT(Access, SHADER_READ_BIT);
        barrier_list.image_barriers[0].subresource_range =
        { SET_FLAG_BIT(ImageAspect, COLOR_BIT), 0, mip_count, 0, 6 };
        cmd_buf->addBarriers(
            barrier_list,
            SET_FLAG_BIT(PipelineStage, TRANSFER_BIT),
            SET_FLAG_BIT(PipelineStage, FRAGMENT_SHADER_BIT) |
            SET_FLAG_BIT(PipelineStage, COMPUTE_SHADER_BIT));
    }
}

void create2x2Texture(
    const renderer::DeviceInfo& device_info,
    uint32_t color,
    renderer::TextureInfo& texture) {
    auto format = renderer::Format::R8G8B8A8_UNORM;
    uint32_t colors[4] = { color };
    renderer::Helper::create2DTextureImage(device_info, format, 2, 2, 4, colors, texture.image, texture.memory);
    texture.view = device_info.device->createImageView(
        texture.image,
        renderer::ImageViewType::VIEW_2D,
        format,
        SET_FLAG_BIT(ImageAspect, COLOR_BIT));
}

/*
    FX implementation of Ken Perlin's "Improved Noise"
    sgg 6/26/04
    http://mrl.nyu.edu/~perlin/noise/
*/
// permutation table
static uint8_t s_permutation[] = { 151,160,137,91,90,15,
    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 };

// gradients for 3d noise
static glm::vec3 s_g[] = {
    {1,1,0},
    {-1,1,0},
    {1,-1,0},
    {-1,-1,0},
    {1,0,1},
    {-1,0,1},
    {1,0,-1},
    {-1,0,-1},
    {0,1,1},
    {0,-1,1},
    {0,1,-1},
    {0,-1,-1},
    {1,1,0},
    {0,-1,1},
    {-1,1,0},
    {0,-1,-1},
};

// gradients for 4D noise
static glm::vec4 s_g4[] = {
    {0, -1, -1, -1},
    {0, -1, -1, 1},
    {0, -1, 1, -1},
    {0, -1, 1, 1},
    {0, 1, -1, -1},
    {0, 1, -1, 1},
    {0, 1, 1, -1},
    {0, 1, 1, 1},
    {-1, -1, 0, -1},
    {-1, 1, 0, -1},
    {1, -1, 0, -1},
    {1, 1, 0, -1},
    {-1, -1, 0, 1},
    {-1, 1, 0, 1},
    {1, -1, 0, 1},
    {1, 1, 0, 1},

    {-1, 0, -1, -1},
    {1, 0, -1, -1},
    {-1, 0, -1, 1},
    {1, 0, -1, 1},
    {-1, 0, 1, -1},
    {1, 0, 1, -1},
    {-1, 0, 1, 1},
    {1, 0, 1, 1},
    {0, -1, -1, 0},
    {0, -1, -1, 0},
    {0, -1, 1, 0},
    {0, -1, 1, 0},
    {0, 1, -1, 0},
    {0, 1, -1, 0},
    {0, 1, 1, 0},
    {0, 1, 1, 0},
};

void createPermutationTexture(
    const renderer::DeviceInfo& device_info,
    renderer::TextureInfo& texture) {
    auto format = renderer::Format::R8_UNORM;
    renderer::Helper::create2DTextureImage(
        device_info,
        format,
        sizeof(s_permutation) / sizeof(int8_t),
        1,
        1,
        s_permutation,
        texture.image,
        texture.memory);

    texture.view = device_info.device->createImageView(
        texture.image,
        renderer::ImageViewType::VIEW_2D,
        format,
        SET_FLAG_BIT(ImageAspect, COLOR_BIT));
}

// 2d permutation texture for optimized version
uint8_t perm(int i)
{
    return s_permutation[i % 256];
}

void createPermutation2DTexture(
    const renderer::DeviceInfo& device_info,
    renderer::TextureInfo& texture) {
    auto format = renderer::Format::R8G8B8A8_UNORM;
    auto n = sizeof(s_permutation) / sizeof(int8_t);
    std::vector<uint32_t> permutation_2d;
    permutation_2d.resize(n * n);
    for (auto y = 0; y < n; y++) {
        for (auto x = 0; x < n; x++) {
            auto idx = y * n + x;
            uint32_t A = perm(x) + y;
            uint32_t AA = perm(A);
            uint32_t AB = perm(A + 1);
            uint32_t B = perm(x + 1) + y;
            uint32_t BA = perm(B);
            uint32_t BB = perm(B + 1);

            permutation_2d[idx] = (BB << 24) | (BA << 16) | (AB << 8) | AA;
        }
    }

    renderer::Helper::create2DTextureImage(
        device_info,
        format,
        static_cast<int>(n),
        static_cast<int>(n),
        4,
        permutation_2d.data(),
        texture.image,
        texture.memory);

    texture.view = device_info.device->createImageView(
        texture.image,
        renderer::ImageViewType::VIEW_2D,
        format,
        SET_FLAG_BIT(ImageAspect, COLOR_BIT));
}

uint8_t safeConvert(float x) {
    auto r = x == 1.0f ? 127 : (x == -1.0f ? 129 : 0);
    return r;
}

uint32_t packInitRgba8(const glm::vec3& data) {
    return safeConvert(data.x) | (safeConvert(data.y) << 8) | (safeConvert(data.z) << 16);
}

uint32_t packInitRgba8(const glm::vec4& data) {
    return safeConvert(data.x) | (safeConvert(data.y) << 8) | (safeConvert(data.z) << 16) | (safeConvert(data.w) << 24);
}

void createGradTexture(
    const renderer::DeviceInfo& device_info,
    renderer::TextureInfo& texture) {
    auto format = renderer::Format::R8G8B8A8_SNORM;
    auto n = sizeof(s_g) / sizeof(glm::vec3);
    std::vector<uint32_t> grad;
    grad.resize(n);
    for (auto i = 0; i < n; i++) {
        grad[i] = packInitRgba8(s_g[i]);
    }
    renderer::Helper::create2DTextureImage(
        device_info,
        format,
        static_cast<uint32_t>(n),
        1,
        4,
        grad.data(),
        texture.image,
        texture.memory);

    texture.view = device_info.device->createImageView(
        texture.image,
        renderer::ImageViewType::VIEW_2D,
        format,
        SET_FLAG_BIT(ImageAspect, COLOR_BIT));
}

void createPermGradTexture(
    const renderer::DeviceInfo& device_info,
    renderer::TextureInfo& texture) {
    auto format = renderer::Format::R8G8B8A8_SNORM;
    auto n = 256;
    std::vector<uint32_t> grad;
    grad.resize(n);
    for (auto i = 0; i < n; i++) {
        grad[i] = packInitRgba8(s_g[s_permutation[i] % 16]);
    }
    renderer::Helper::create2DTextureImage(
        device_info,
        format,
        n,
        1,
        4,
        grad.data(),
        texture.image,
        texture.memory);

    texture.view = device_info.device->createImageView(
        texture.image,
        renderer::ImageViewType::VIEW_2D,
        format,
        SET_FLAG_BIT(ImageAspect, COLOR_BIT));
}

void createPermGrad4DTexture(
    const renderer::DeviceInfo& device_info,
    renderer::TextureInfo& texture) {
    auto format = renderer::Format::R8G8B8A8_SNORM;
    auto n = 256;
    std::vector<uint32_t> grad;
    grad.resize(n);
    for (auto i = 0; i < n; i++) {
        grad[i] = packInitRgba8(s_g4[s_permutation[i] % 32]);
    }
    renderer::Helper::create2DTextureImage(
        device_info,
        format,
        n,
        1,
        4,
        grad.data(),
        texture.image,
        texture.memory);

    texture.view = device_info.device->createImageView(
        texture.image,
        renderer::ImageViewType::VIEW_2D,
        format,
        SET_FLAG_BIT(ImageAspect, COLOR_BIT));
}

void createGrad4DTexture(
    const renderer::DeviceInfo& device_info,
    renderer::TextureInfo& texture) {
    auto format = renderer::Format::R8G8B8A8_SNORM;
    auto n = 32;
    std::vector<uint32_t> grad;
    grad.resize(n);
    for (auto i = 0; i < n; i++) {
        grad[i] = packInitRgba8(s_g4[i]);
    }
    renderer::Helper::create2DTextureImage(
        device_info,
        format,
        n,
        1,
        4,
        grad.data(),
        texture.image,
        texture.memory);

    texture.view = device_info.device->createImageView(
        texture.image,
        renderer::ImageViewType::VIEW_2D,
        format,
        SET_FLAG_BIT(ImageAspect, COLOR_BIT));
}

std::vector<VkPipelineShaderStageCreateInfo> getComputeShaderStages(
    const std::vector<std::shared_ptr<renderer::ShaderModule>>& shader_modules) {
    std::vector<VkPipelineShaderStageCreateInfo> shader_stages(shader_modules.size());

    // todo.
    for (int i = 0; i < shader_modules.size(); i++) {
        auto vk_comp_shader_module = RENDER_TYPE_CAST(ShaderModule, shader_modules[i]);
        shader_stages[i].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        shader_stages[i].stage = VK_SHADER_STAGE_COMPUTE_BIT;
        shader_stages[i].module = vk_comp_shader_module->get();
        shader_stages[i].pName = "main";
    }

    return std::move(shader_stages);
}

VkPipelineVertexInputStateCreateInfo fillVkPipelineVertexInputStateCreateInfo(
    const std::vector<VkVertexInputBindingDescription>& binding_descs,
    const std::vector<VkVertexInputAttributeDescription>& attribute_descs) {
    VkPipelineVertexInputStateCreateInfo vertex_input_info{};
    vertex_input_info.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertex_input_info.vertexBindingDescriptionCount = static_cast<uint32_t>(binding_descs.size());
    vertex_input_info.pVertexBindingDescriptions = binding_descs.data();
    vertex_input_info.vertexAttributeDescriptionCount = static_cast<uint32_t>(attribute_descs.size());
    vertex_input_info.pVertexAttributeDescriptions = attribute_descs.data();

    return vertex_input_info;
}

VkPipelineInputAssemblyStateCreateInfo fillVkPipelineInputAssemblyStateCreateInfo(
    const renderer::PipelineInputAssemblyStateCreateInfo& topology_info) {
    VkPipelineInputAssemblyStateCreateInfo input_assembly{};
    input_assembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    input_assembly.topology = toVkPrimitiveTopology(topology_info.topology);
    input_assembly.primitiveRestartEnable = topology_info.restart_enable;

    return input_assembly;
}

std::vector<VkPipelineColorBlendAttachmentState> fillVkPipelineColorBlendAttachments(
    const renderer::PipelineColorBlendStateCreateInfo& blend_info) {
    std::vector<VkPipelineColorBlendAttachmentState> attachments(blend_info.attachment_count);
    for (uint32_t i = 0; i < blend_info.attachment_count; i++) {
        auto& src_att = blend_info.attachments[i];
        attachments[i].blendEnable = src_att.blend_enable ? VK_TRUE : VK_FALSE;
        attachments[i].srcColorBlendFactor = toVkBlendFactor(src_att.src_color_blend_factor);
        attachments[i].dstColorBlendFactor = toVkBlendFactor(src_att.dst_color_blend_factor);
        attachments[i].colorBlendOp = toVkBlendOp(src_att.color_blend_op);
        attachments[i].srcAlphaBlendFactor = toVkBlendFactor(src_att.src_alpha_blend_factor);
        attachments[i].dstAlphaBlendFactor = toVkBlendFactor(src_att.dst_alpha_blend_factor);
        attachments[i].alphaBlendOp = toVkBlendOp(src_att.alpha_blend_op);
        attachments[i].colorWriteMask = toVkColorComponentFlags(src_att.color_write_mask);
    }

    return attachments;
}

VkPipelineColorBlendStateCreateInfo fillVkPipelineColorBlendStateCreateInfo(
    const renderer::PipelineColorBlendStateCreateInfo& blend_info,
    const std::vector<VkPipelineColorBlendAttachmentState>& attachments) {
    VkPipelineColorBlendStateCreateInfo color_blending{};
    color_blending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    color_blending.logicOpEnable = blend_info.logic_op_enable ? VK_TRUE : VK_FALSE;
    color_blending.logicOp = toVkLogicOp(blend_info.logic_op);
    color_blending.attachmentCount = static_cast<uint32_t>(attachments.size());
    color_blending.pAttachments = attachments.data();
    color_blending.blendConstants[0] = blend_info.blend_constants.x;
    color_blending.blendConstants[1] = blend_info.blend_constants.y;
    color_blending.blendConstants[2] = blend_info.blend_constants.z;
    color_blending.blendConstants[3] = blend_info.blend_constants.w;

    return color_blending;
}

VkPipelineRasterizationStateCreateInfo fillVkPipelineRasterizationStateCreateInfo(
    const renderer::PipelineRasterizationStateCreateInfo& rasterization_info) {
    VkPipelineRasterizationStateCreateInfo rasterizer{};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = rasterization_info.depth_clamp_enable ? VK_TRUE : VK_FALSE;
    rasterizer.rasterizerDiscardEnable = rasterization_info.rasterizer_discard_enable ? VK_TRUE : VK_FALSE;
    rasterizer.polygonMode = toVkPolygonMode(rasterization_info.polygon_mode);
    rasterizer.lineWidth = rasterization_info.line_width;
    rasterizer.cullMode = toVkCullModeFlags(rasterization_info.cull_mode);
    rasterizer.frontFace = toVkFrontFace(rasterization_info.front_face);
    rasterizer.depthBiasEnable = rasterization_info.depth_bias_enable ? VK_TRUE : VK_FALSE;
    rasterizer.depthBiasConstantFactor = rasterization_info.depth_bias_constant_factor; // Optional
    rasterizer.depthBiasClamp = rasterization_info.depth_bias_clamp; // Optional
    rasterizer.depthBiasSlopeFactor = rasterization_info.depth_bias_slope_factor; // Optional

    return rasterizer;
}

VkPipelineMultisampleStateCreateInfo fillVkPipelineMultisampleStateCreateInfo(
    const renderer::PipelineMultisampleStateCreateInfo& ms_info) {
    VkPipelineMultisampleStateCreateInfo multisampling{};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = ms_info.sample_shading_enable ? VK_TRUE : VK_FALSE;
    multisampling.rasterizationSamples = static_cast<VkSampleCountFlagBits>(toVkSampleCountFlags(static_cast<renderer::SampleCountFlags>(ms_info.rasterization_samples)));
    multisampling.minSampleShading = ms_info.min_sample_shading; // Optional
    multisampling.pSampleMask = ms_info.sample_mask; // Optional
    multisampling.alphaToCoverageEnable = ms_info.alpha_to_coverage_enable ? VK_TRUE : VK_FALSE; // Optional
    multisampling.alphaToOneEnable = ms_info.alpha_to_one_enable ? VK_TRUE : VK_FALSE; // Optional

    return multisampling;
}

VkViewport fillViewport(const glm::uvec2 size) {
    VkViewport viewport{};
    viewport.x = 0.0f;
    viewport.y = 0.0f;
    viewport.width = (float)size.x;
    viewport.height = (float)size.y;
    viewport.minDepth = 0.0f;
    viewport.maxDepth = 1.0f;

    return viewport;
}

VkRect2D fillScissor(const glm::uvec2 size) {
    VkRect2D scissor{};
    scissor.offset = { 0, 0 };
    scissor.extent = { size.x, size.y };

    return scissor;
}

VkPipelineViewportStateCreateInfo fillVkPipelineViewportStateCreateInfo(const VkViewport* viewport, const VkRect2D* scissor) {
    VkPipelineViewportStateCreateInfo viewport_state{};
    viewport_state.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewport_state.viewportCount = 1;
    viewport_state.pViewports = viewport;
    viewport_state.scissorCount = 1;
    viewport_state.pScissors = scissor;

    return viewport_state;
}

std::vector<VkPipelineColorBlendAttachmentState> fillVkPipelineColorBlendAttachmentState(uint32_t num_attachments) {
    std::vector<VkPipelineColorBlendAttachmentState> color_blend_attachements(num_attachments);
    VkPipelineColorBlendAttachmentState color_blend_attachment{};
    color_blend_attachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    color_blend_attachment.blendEnable = VK_FALSE;
    color_blend_attachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; // Optional
    color_blend_attachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional
    color_blend_attachment.colorBlendOp = VK_BLEND_OP_ADD; // Optional
    color_blend_attachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; // Optional
    color_blend_attachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; // Optional
    color_blend_attachment.alphaBlendOp = VK_BLEND_OP_ADD; // Optional

    for (uint32_t i = 0; i < num_attachments; i++) {
        color_blend_attachements[i] = color_blend_attachment;
    }

    return std::move(color_blend_attachements);
}

VkStencilOpState fillVkStencilOpState(const renderer::StencilOpState& stencil_op) {
    VkStencilOpState vk_stencil_op{};
    vk_stencil_op.failOp = toVkStencilOp(stencil_op.fail_op);
    vk_stencil_op.passOp = toVkStencilOp(stencil_op.pass_op);
    vk_stencil_op.depthFailOp = toVkStencilOp(stencil_op.depth_fail_op);
    vk_stencil_op.compareOp = toVkCompareOp(stencil_op.compare_op);
    vk_stencil_op.compareMask = stencil_op.compare_mask;
    vk_stencil_op.writeMask = stencil_op.write_mask;
    vk_stencil_op.reference = stencil_op.reference;
    return vk_stencil_op;
}

VkPipelineDepthStencilStateCreateInfo fillVkPipelineDepthStencilStateCreateInfo(
    const renderer::PipelineDepthStencilStateCreateInfo& depth_stencil_info) {
    VkPipelineDepthStencilStateCreateInfo depth_stencil{};
    depth_stencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depth_stencil.depthTestEnable = depth_stencil_info.depth_test_enable ? VK_TRUE : VK_FALSE;
    depth_stencil.depthWriteEnable = depth_stencil_info.depth_write_enable ? VK_TRUE : VK_FALSE;
    depth_stencil.depthCompareOp = toVkCompareOp(depth_stencil_info.depth_compare_op);
    depth_stencil.depthBoundsTestEnable = depth_stencil_info.depth_bounds_test_enable ? VK_TRUE : VK_FALSE;
    depth_stencil.minDepthBounds = depth_stencil_info.min_depth_bounds; // Optional
    depth_stencil.maxDepthBounds = depth_stencil_info.max_depth_bounds; // Optional
    depth_stencil.stencilTestEnable = depth_stencil_info.stencil_test_enable ? VK_TRUE : VK_FALSE;
    depth_stencil.front = fillVkStencilOpState(depth_stencil_info.front); // Optional
    depth_stencil.back = fillVkStencilOpState(depth_stencil_info.back); // Optional

    return depth_stencil;
}

VkAttachmentDescription FillVkAttachmentDescription(
    const renderer::AttachmentDescription& attachment_desc) {
    VkAttachmentDescription attachment{};
    attachment.format = toVkFormat(attachment_desc.format);
    attachment.samples = static_cast<VkSampleCountFlagBits>(toVkSampleCountFlags(static_cast<renderer::SampleCountFlags>(attachment_desc.samples)));
    attachment.initialLayout = toVkImageLayout(attachment_desc.initial_layout);
    attachment.finalLayout = toVkImageLayout(attachment_desc.final_layout);
    attachment.loadOp = VkAttachmentLoadOp(attachment_desc.load_op);
    attachment.storeOp = VkAttachmentStoreOp(attachment_desc.store_op);
    attachment.stencilLoadOp = VkAttachmentLoadOp(attachment_desc.stencil_load_op);
    attachment.stencilStoreOp = VkAttachmentStoreOp(attachment_desc.stencil_store_op);

    return attachment;
}

std::vector<VkAttachmentReference> FillVkAttachmentReference(
    const std::vector<renderer::AttachmentReference>& attachment_references) {
    const size_t& num_atts = attachment_references.size();
    std::vector<VkAttachmentReference> vk_attachment_references(num_atts);
    for (auto i = 0; i < num_atts; i++) {
        vk_attachment_references[i].attachment = attachment_references[i].attachment_;
        vk_attachment_references[i].layout = toVkImageLayout(attachment_references[i].layout_);
    }
    return vk_attachment_references;
}

VkSubpassDescription FillVkSubpassDescription(
    const renderer::SubpassDescription& subpass,
    const SubpassAttachments& attachments) {
    VkSubpassDescription vk_desc{};
    vk_desc.flags = toVkSubpassDescriptionFlags(subpass.flags);
    vk_desc.pipelineBindPoint = toVkPipelineBindPoint(subpass.pipeline_bind_point);
    vk_desc.inputAttachmentCount = static_cast<uint32_t>(attachments.input_attachments.size());
    vk_desc.pInputAttachments = vk_desc.inputAttachmentCount > 0 ? attachments.input_attachments.data() : nullptr;
    vk_desc.colorAttachmentCount = static_cast<uint32_t>(attachments.color_attachments.size());
    vk_desc.pColorAttachments = vk_desc.colorAttachmentCount > 0 ? attachments.color_attachments.data() : nullptr;
    vk_desc.pResolveAttachments = attachments.resolve_attachments.size() > 0 ? attachments.resolve_attachments.data() : nullptr;
    vk_desc.pDepthStencilAttachment = attachments.depth_stencil_attachment.size() > 0 ? attachments.depth_stencil_attachment.data() : nullptr;
    return vk_desc;
}

VkSubpassDependency FillVkSubpassDependency(
    const renderer::SubpassDependency& dependency) {
    VkSubpassDependency vk_dependency{};
    vk_dependency.srcSubpass = dependency.src_subpass;
    vk_dependency.dstSubpass = dependency.dst_subpass;
    vk_dependency.srcStageMask = toVkPipelineStageFlags(dependency.src_stage_mask);
    vk_dependency.dstStageMask = toVkPipelineStageFlags(dependency.dst_stage_mask);
    vk_dependency.srcAccessMask = toVkAccessFlags(dependency.src_access_mask);
    vk_dependency.dstAccessMask = toVkAccessFlags(dependency.dst_access_mask);
    vk_dependency.dependencyFlags = toVkDependencyFlags(dependency.dependency_flags);
    return vk_dependency;
}

} // namespace helper
} // namespace vk
} // namespace renderer
} // namespace engine
